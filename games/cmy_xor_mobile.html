<!doctype html>
<html lang="en">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-20EEFX7Q6N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-20EEFX7Q6N');
</script>
  <meta charset="utf-8" />
  <meta name="viewport" content="width=device-width,initial-scale=1" />
  <title>Colored XOR — Mobile</title>

  <style>
    :root{
      --cell: 28px;
      --cellMini: 14px;
      --gap: 2px;

      --bg0:#060913;
      --bg1:#0a1222;

      --panelA: rgba(255,255,255,.045);
      --panelB: rgba(255,255,255,.020);

      --line: rgba(125,160,220,.18);
      --text:#eaf1fb;
      --muted:#9fb1c9;

      --accent:#7aa2ff;
      --ok:#2dd4bf;
      --bad:#fb7185;

      --r: 18px;
      --shadow: 0 18px 48px rgba(0,0,0,.45);
    }

    *{ box-sizing:border-box; }
    body{
      margin:0;
      font-family: system-ui, -apple-system, Segoe UI, Roboto, Helvetica, Arial, sans-serif;
      color: var(--text);
      background:
        radial-gradient(1100px 650px at 18% 0%, rgba(122,162,255,.18), transparent 58%),
        radial-gradient(900px 520px at 85% 5%, rgba(45,212,191,.10), transparent 55%),
        linear-gradient(180deg, var(--bg0), var(--bg1) 55%, var(--bg0));
    }

    .wrap{
      max-width: 1280px;
      margin: 0 auto;
      padding: 18px;
      display: grid;
      grid-template-columns: 470px minmax(0, 1fr);
      gap: 14px;
      align-items: start;
    }
    @media (max-width: 980px){
      .wrap{ grid-template-columns: 1fr; }
    }

    /* Mobile-only layout overrides */
    :root{
      --pagePad: 12px;
    }
    .wrap{
      max-width: 980px;
      grid-template-columns: 1fr !important;
      padding: var(--pagePad) !important;
    }
    .wrap > .card:first-child{
      display:none !important;
    }
    .rightTop,
    .row.controlsRow{
      display:none !important;
    }
    .mobileOptions{
      display:block !important;
      position: fixed !important;
      top: var(--pagePad) !important;
      left: var(--pagePad) !important;
      margin: 0 !important;
      padding: 0 !important;
      z-index: 30;
    }
    .mobileOptions .menuBtn{
      width: 72px;
      height: 72px;
      padding: 0;
      border: none;
      background: transparent;
      color: inherit;
      font-size: 30px;
      line-height: 1;
      cursor: pointer;
    }
    .menuPanel{
      position: absolute;
      top: 76px;
      left: 0;
      min-width: 180px;
      padding: 6px;
      border-radius: 12px;
      border: 1px solid rgba(125,160,220,.25);
      background: rgba(10,14,22,.95);
      box-shadow: 0 12px 28px rgba(0,0,0,.45);
      display: none;
      flex-direction: column;
      gap: 2px;
      z-index: 40;
    }
    .menuPanel.on{ display: flex; }
    .menuItem{
      text-align: left;
      font-size: 12px;
      font-weight: 700;
      color: rgba(234,241,251,.92);
      background: transparent;
      border: none;
      padding: 6px 10px;
      border-radius: 8px;
      cursor: pointer;
    }
    .menuItem:hover{ background: rgba(255,255,255,.06); }
    .menuSep{
      height: 1px;
      background: rgba(255,255,255,.08);
      margin: 4px 2px;
    }
    .boards{
      grid-template-columns: 1fr !important;
      grid-template-rows: auto auto auto !important;
      gap: 6px !important;
      padding: var(--pagePad) !important;
      margin-top: 48px !important;
      justify-items: start !important;
      align-items: start !important;
    }
    .targetRow{
      flex-direction: row !important;
      align-items: flex-start !important;
      justify-content: flex-start !important;
      flex-wrap: nowrap !important;
      gap: 4px !important;
    }
    .targetStack{
      align-items: flex-start !important;
      gap: 4px !important;
    }
    .targetLabel{
      text-align: center !important;
      width: 100% !important;
    }
    .targetLabelRow{
      width: 100% !important;
      justify-content: center !important;
    }
    .paletteWrap.nearBoard{
      max-width: none !important;
      width: auto !important;
      order: 0 !important;
    }
    .mobilePreview{
      width: 100% !important;
      flex-wrap: nowrap !important;
      justify-content: center !important;
      gap: 2px !important;
    }
    .mobilePreview .colorPicker{
      width: auto !important;
      justify-content: center !important;
      order: 0 !important;
    }
    .board{
      border: none !important;
      background: transparent !important;
      box-shadow: none !important;
      width: 100% !important;
    }
    .paletteWrap,
    .paletteWrap.nearBoard{
      border: none !important;
      background: transparent !important;
      padding: 0 !important;
    }
    .gridWrap{
      width: 100% !important;
      display:flex !important;
      justify-content:flex-start !important;
      overflow: hidden !important;
    }
    .board .gridWrap{
      justify-content: center !important;
    }
      #playGrid{
        --cell: clamp(15px, calc((100vw - 8px - (var(--n) - 1) * var(--gap)) / var(--n)), 28px) !important;
      }

    .card{
      border: 1px solid var(--line);
      border-radius: var(--r);
      box-shadow: var(--shadow);
      background: linear-gradient(180deg, var(--panelA), var(--panelB));
      backdrop-filter: blur(10px);
      overflow: hidden;
    }

    .head{
      padding: 14px 14px 12px;
      border-bottom: 1px solid var(--line);
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
    }
    .title{
      margin:0;
      font-size: 16px;
      font-weight: 820;
      letter-spacing: .2px;
      display:flex;
      gap: 10px;
      align-items:center;
      flex-wrap: wrap;
    }
    .badge{
      font-size: 11px;
      font-weight: 750;
      padding: 3px 8px;
      border-radius: 999px;
      border: 1px solid rgba(122,162,255,.35);
      background: rgba(122,162,255,.10);
      color: rgba(234,241,251,.92);
    }
    .sub{
      margin: 8px 0 0;
      color: var(--muted);
      font-size: 12.6px;
      line-height: 1.45;
    }

    .body{ padding: 14px; }
    .row{ display:flex; gap:10px; flex-wrap: wrap; align-items:center; }

    .btn{
      appearance:none;
      border: 1px solid rgba(125,160,220,.22);
      background: rgba(255,255,255,.03);
      color: var(--text);
      padding: 8px 10px;
      border-radius: 12px;
      cursor:pointer;
      font-weight: 760;
      font-size: 13px;
      transition: transform .06s ease, border-color .15s ease, background .15s ease;
      user-select:none;
      white-space: nowrap;
    }
    .btn:hover{ border-color: rgba(125,160,220,.42); background: rgba(255,255,255,.05); }
    .btn:active{ transform: translateY(1px); }

    .btn.primary{
      border-color: rgba(122,162,255,.55);
      background: rgba(122,162,255,.10);
    }
    .btn.primary:hover{ border-color: rgba(122,162,255,1); background: rgba(122,162,255,.14); }

    .btn.good{
      border-color: rgba(45,212,191,.50);
      background: rgba(45,212,191,.10);
    }
    .btn.good:hover{ border-color: rgba(45,212,191,1); background: rgba(45,212,191,.14); }

    .btn.toggled{
      border-color: rgba(122,162,255,.95);
      background: rgba(122,162,255,.16);
    }

    .btn.small{ padding: 6px 9px; font-size: 12px; border-radius: 11px; }

    .kbd{
      font-family: ui-monospace, SFMono-Regular, Menlo, Monaco, Consolas, "Liberation Mono", monospace;
      font-size: 12px;
      padding: 2px 6px;
      border: 1px solid rgba(125,160,220,.22);
      border-radius: 9px;
      color: var(--muted);
      background: rgba(255,255,255,.03);
      display:inline-block;
    }

    .chip{
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(125,160,220,.22);
      background: rgba(255,255,255,.03);
      color: var(--muted);
      font-size: 12px;
      font-weight: 740;
      display:flex;
      align-items:center;
      gap:8px;
      user-select:none;
    }
    select{
      appearance:none;
      padding: 5px 9px;
      border-radius: 12px;
      border: 1px solid rgba(125,160,220,.22);
      background: rgba(255,255,255,.03);
      color: var(--text);
      font-weight: 760;
      font-size: 12px;
      cursor:pointer;
    }
    option{
      color: #0b1220;
      background: #f7f9ff;
      font-weight: 700;
    }

    .stats{
      display:grid;
      grid-template-columns: 1fr 1fr;
      gap: 10px;
      margin-top: 12px;
    }
    .stat{
      border: 1px solid rgba(125,160,220,.22);
      border-radius: 14px;
      padding: 10px;
      background: rgba(255,255,255,.02);
    }
    .stat .k{ color: var(--muted); font-size: 12px; }
    .stat .v{ margin-top: 2px; font-size: 16px; font-weight: 860; }

    .meter{
      margin-top: 10px;
      border: 1px solid rgba(125,160,220,.18);
      border-radius: 999px;
      background: rgba(0,0,0,.12);
      overflow:hidden;
      height: 10px;
    }
    .bar{
      height: 100%;
      width: 0%;
      background: linear-gradient(90deg, rgba(45,212,191,.65), rgba(122,162,255,.65));
      transition: width .15s ease;
    }

    .paletteWrap{
      margin-top: 14px;
      border: 1px solid rgba(125,160,220,.18);
      border-radius: 16px;
      background: rgba(0,0,0,.10);
      padding: 10px;
    }
    .paletteWrap.nearBoard{
      margin: 0;
      padding: 8px;
      max-width: 180px;
    }
    .palette{
      display:grid;
      grid-template-columns: repeat(4, 1fr);
      gap: 10px;
    }
    .palette.compact{
      display:flex;
      flex-wrap: wrap;
      justify-content:center;
      align-content:flex-start;
      gap: 0;
      --thumb: 42px;
      --frame: 42px;
    }
    .piece{
      border: none;
      border-radius: 0;
      padding: 0;
      background: transparent;
      cursor:pointer;
      user-select:none;
      display:flex;
      align-items:center;
      justify-content:center;
      transition: border-color .15s ease, background .15s ease, transform .06s ease;
      min-width: 0;
    }
    .piece:hover{ background: transparent; }
    .piece:active{ transform: translateY(1px); }
    .piece.selected{
      border-color: transparent;
      background: transparent;
      box-shadow: none;
    }
    .piece .name{
      font-size: 12px;
      font-weight: 820;
      letter-spacing: .2px;
      color: var(--muted);
    }
    .palette .name{ display:none; }
    canvas.thumb{
      width: 64px; height: 64px;
      image-rendering: pixelated;
      border-radius: 14px;
      background: transparent;
      border: none;
    }
    .palette.compact canvas.thumb{
      width: var(--thumb);
      height: var(--thumb);
      border-radius: 0;
    }
    .palette.compact .piece{
      width: var(--frame);
      height: var(--frame);
      padding: 0;
      border-radius: 0;
      border: none;
      background: transparent;
      box-shadow: none;
      margin: -10px -6px;
    }
    .palette.compact .piece:hover{ background: transparent; }
    .palette.compact .piece.selected canvas.thumb{
      filter:
        drop-shadow(0 0 0 rgba(122,162,255,1))
        drop-shadow(0 0 8px rgba(122,162,255,.85))
        drop-shadow(0 0 18px rgba(122,162,255,.55))
        drop-shadow(0 0 30px rgba(122,162,255,.35));
    }
    .palette.compact .name{
      font-size: 10px;
    }
    .swatches{ display:flex; gap:6px; }
    .sw{
      width: 14px; height: 14px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.14);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.18);
      cursor:pointer;
      opacity:.85;
      transition: transform .06s ease, opacity .12s ease, box-shadow .12s ease;
    }
    .sw:hover{ opacity:1; transform: translateY(-1px); }
    .sw.sel{ opacity:1; box-shadow: 0 0 0 2px rgba(122,162,255,.35); }

    /* RIGHT */
    .rightTop{
      padding: 12px 14px;
      border-bottom: 1px solid var(--line);
      display:flex;
      justify-content: space-between;
      align-items:center;
      gap: 10px;
      flex-wrap: wrap;
      background: linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.01));
    }
    .status{
      font-size: 13px;
      color: var(--muted);
      min-width: 280px;
      flex: 1 1 280px;
      line-height: 1.35;
    }
    .pillLine{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
      justify-content: flex-end;
    }
    .pill2{
      padding: 4px 8px;
      border-radius: 999px;
      border: 1px solid rgba(125,160,220,.22);
      background: rgba(255,255,255,.03);
      color: rgba(234,241,251,.90);
      font-size: 12px;
      font-weight: 750;
    }
    .pill2.ok{ border-color: rgba(45,212,191,.55); color: rgba(45,212,191,.95); }
    .pill2.bad{ border-color: rgba(251,113,133,.55); color: rgba(251,113,133,.95); }

    .boardControls{
      display:flex;
      gap: 8px;
      flex-wrap: wrap;
      align-items:center;
      justify-content:flex-end;
      margin-left: auto;
    }

    .boards{
      display:grid;
      gap: 14px;
      padding: 14px;
      align-items:center;
      justify-items:center;
      grid-template-columns: 1fr;
      grid-template-rows: auto auto auto;
    }
    .targetRow{
      display:flex;
      gap: 12px;
      align-items:flex-start;
      flex-wrap: wrap;
    }
    .targetStack{
      display:flex;
      flex-direction: column;
      align-items:flex-start;
      gap: 6px;
    }
    .targetRow{
      align-items: stretch;
    }
    .targetLabel{
      font-size: 12.5px;
      font-weight: 820;
      color: rgba(234,241,251,.92);
      letter-spacing: .2px;
    }
    .targetLabelRow{
      display:flex;
      align-items:center;
      gap: 10px;
      width: 100%;
      justify-content: center;
    }
    .targetRow .paletteWrap{
      align-self: stretch;
    }
    .targetRow .paletteWrap{
      padding: 8px;
    }
    .colorPicker{
      display:flex;
      gap: 8px;
      align-items:center;
      padding: 6px 10px;
      border-radius: 12px;
      border: 1px solid rgba(125,160,220,.22);
      background: transparent;
      height: 44px;
      min-width: 96px;
    }
    .colorBtn{
      width: 20px;
      height: 20px;
      border-radius: 6px;
      border: 1px solid rgba(255,255,255,.25);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.2);
      cursor:pointer;
      opacity: .85;
    }
    .colorBtn.sel{
      outline: 2px solid rgba(122,162,255,.8);
      outline-offset: 2px;
      opacity: 1;
    }
    #rotateBtn{
      font-size: 30px;
      line-height: 1;
      padding: 8px 12px;
      min-width: 56px;
    }
    #undoBtn,
    #redoBtn{
      font-size: 21px;
      line-height: 1;
      padding: 8px 10px;
      min-width: 48px;
    }
    .mobilePreview .btn{
      height: 44px;
    }
    .mobilePreview{
      display:flex;
      align-items:center;
      gap: 5px;
      padding: 4px 6px;
      border-radius: 0;
      border: none;
      background: transparent;
      min-width: 0;
    }
    .mobilePreview canvas{
      width: 60px;
      height: 60px;
      border-radius: 0;
      border: 1px solid rgba(125,160,220,.35);
      background: rgba(255,255,255,.03);
      image-rendering: pixelated;
    }
    .board{
      border: 1px solid rgba(125,160,220,.22);
      border-radius: 16px;
      padding: 12px;
      background: rgba(255,255,255,.02);
    }
    .boardTitle{
      margin: 0 0 10px;
      font-size: 12px;
      font-weight: 860;
      letter-spacing: .3px;
      display:flex;
      align-items:center;
      gap: 8px;
      color: rgba(234,241,251,.92);
    }
    .boardTitle span{ color: var(--muted); font-weight: 720; letter-spacing: 0; }

    .gridWrap{ position: relative; width: fit-content; }
    .grid{
      display:grid;
      gap: var(--gap);
      width: fit-content;
      padding: 10px;
      border-radius: 16px;
      background: rgba(0,0,0,.12);
      border: 1px solid rgba(255,255,255,.06);
      user-select:none;
      touch-action:none;
      position: relative;
      z-index: 1;
    }
    .cell{
      width: var(--cell);
      height: var(--cell);
      border-radius: 4px;
      background: rgba(244,247,251,.96);
      box-shadow: inset 0 0 0 1px rgba(0,0,0,.12);
      position: relative;
      overflow: hidden;
    }

    .cell.ghost{
      outline: 2px solid rgba(122,162,255,.78);
      outline-offset: -2px;
    }
    .cell.ghost.bad{ outline-color: rgba(251,113,133,.85); }
    .cell.ghost::after{
      content: "";
      position:absolute;
      inset: 0;
      border-radius: 4px;
      background: rgba(0,0,0,.18);
      box-shadow: inset 0 0 0 2px rgba(122,162,255,.55);
      pointer-events:none;
    }
    .cell.ghost.bad::after{
      background: rgba(251,113,133,.12);
      box-shadow: inset 0 0 0 2px rgba(251,113,133,.65);
    }

    .cell.mismatch::after{
      content: "";
      position:absolute;
      inset: 0;
      border-radius: 4px;
      box-shadow: inset 0 0 0 2px rgba(251,113,133,.55);
      background: rgba(251,113,133,.08);
      pointer-events:none;
    }

    .mini{ padding: 8px; }
    .mini .cell{ width: var(--cellMini); height: var(--cellMini); border-radius: 4px; }
    #targetGrid{
      --cellMini: 12.5px;
    }
    #targetGrid .cell,
    #targetGrid .cell.ghost::after,
    #targetGrid .cell.mismatch::after{
      border-radius: 2px;
    }

    #solCanvas{
      position:absolute;
      inset: 0;
      z-index: 2;
      pointer-events:none;
      opacity: 0;
      transition: opacity .15s ease;
    }
    #solCanvas.on{ opacity: 1; }

    .legendTiny{
      margin-top: 10px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }

    .footerHint{
      padding: 0 14px 14px;
      color: var(--muted);
      font-size: 12px;
      line-height: 1.5;
    }

    .moveFooter{
      margin-top: 8px;
      color: var(--muted);
      font-size: 12px;
      font-weight: 700;
      text-align: center;
    }
    .howtoModal{
      position: fixed;
      inset: 0;
      background: rgba(6,9,19,.65);
      display: none;
      align-items: center;
      justify-content: center;
      z-index: 20;
      padding: 16px;
    }
    .howtoModal.on{ display:flex; }
    .howtoCard{
      max-width: 360px;
      width: 100%;
      border: 1px solid rgba(125,160,220,.25);
      border-radius: 14px;
      padding: 14px;
      background: linear-gradient(180deg, rgba(20,28,48,.98), rgba(10,18,34,.98));
      box-shadow: var(--shadow);
      color: var(--text);
      font-size: 13px;
      line-height: 1.45;
    }
    .howtoHead{
      display:flex;
      align-items:center;
      justify-content: space-between;
      gap: 10px;
      font-weight: 800;
      margin-bottom: 8px;
    }
    .historyList{
      display:flex;
      flex-direction: column;
      gap: 8px;
      max-height: 60vh;
      overflow: auto;
    }
    .historyItem{
      border: 1px solid rgba(125,160,220,.2);
      border-radius: 10px;
      padding: 8px;
      background: rgba(255,255,255,.03);
      font-size: 12px;
      line-height: 1.35;
      display:flex;
      justify-content: space-between;
      gap: 10px;
    }
    .historyItem .meta{
      color: var(--muted);
      font-size: 11px;
    }
    .moveFooter.solved{
      color: rgba(45,212,191,.95);
      font-weight: 800;
    }
    .mobileOptions{
      display:none;
    }
    .mobileOptions .menuBtn{
      width: 72px;
      height: 72px;
      font-size: 30px;
      font-weight: 800;
      border: none;
      background: transparent;
      box-shadow: none;
      outline: none;
      padding: 0;
      text-align: center;
      color: inherit;
    }
    .mobileOptions .menuBtn:focus{
      outline: none;
      box-shadow: none;
    }
    .fixedCluster{ display:none; }

    @media (max-width: 820px){
      .boardControls{ justify-content: flex-start; }
    }
    @media (max-width: 700px){
      .mobileOptions{ display:block; }
      .row.controlsRow{ display:none; }
      .rightTop{ display:none; }
      .wrap > .card:first-child{ display:none; }
      .card{ border: none; background: transparent; box-shadow: none; }
      :root{
        --cellMini: 11px;
      }
      .board,
      .targetRow,
      .mobilePreview{
        width: 100%;
        align-items: flex-start;
      }
      .targetRow{
        flex-direction: column;
        align-items: flex-start;
      }
      .targetStack{
        align-items: flex-start;
        gap: 4px;
      }
      .targetLabel{
        text-align: center;
        width: 100%;
      }
      .targetLabelRow{
        width: 100%;
        justify-content: center;
      }
      .gridWrap{
        width: 100%;
        display:flex;
        justify-content:flex-start;
      }
      .board .gridWrap{
        justify-content:center;
      }
      #playGrid{
        --cell: clamp(13px, calc((100vw - 20px - (var(--n) - 1) * var(--gap)) / var(--n)), 24px);
      }
      .targetRow{ gap: 6px; }
      .grid{ padding: 2px; }
      .gridWrap{ max-width: 100%; overflow: hidden; }
      .paletteWrap.nearBoard{
        max-width: none;
        width: 100%;
        order: 2;
      }
      .palette.compact{
        --thumb: 54px;
        --frame: 68px;
        gap: 0;
      }
      .palette.compact canvas.thumb{
        width: var(--thumb);
        height: var(--thumb);
      }
      .colorBtn{
        width: 16px;
        height: 16px;
      }
      #rotateBtn{
        font-size: 26px;
        min-width: 50px;
        padding: 6px 10px;
      }
      #undoBtn,
      #redoBtn{
        font-size: 19px;
        min-width: 44px;
        padding: 6px 10px;
      }
      .mobilePreview{
        padding: 2px 4px;
        gap: 2px;
        flex-wrap: nowrap;
        justify-content: center;
      }
      .mobilePreview canvas{
        width: 45px;
        height: 45px;
      }
      .mobilePreview .colorPicker{
        width: auto;
        justify-content: center;
        order: 0;
      }
    }
    @media (max-width: 600px){
      :root{
        --gap: 1px;
      }
      #playGrid{
        --cell: clamp(12px, calc((100vw - 16px - (var(--n) - 1) * var(--gap)) / var(--n)), 22px);
      }
      .palette.compact{
        --thumb: 48px;
        --frame: 62px;
        gap: 0;
      }
      .palette.compact canvas.thumb{
        width: var(--thumb);
        height: var(--thumb);
      }
      .colorBtn{
        width: 14px;
        height: 14px;
      }
      #rotateBtn{
        font-size: 24px;
        min-width: 46px;
        padding: 5px 10px;
      }
      #undoBtn,
      #redoBtn{
        font-size: 17px;
        min-width: 40px;
        padding: 5px 10px;
      }
      .mobilePreview canvas{
        width: 42px;
        height: 42px;
      }
    }
    @media (max-width: 980px){
      .boards{
        grid-template-columns: 1fr;
        justify-items:center;
      }
      .midControls{
        justify-content:center;
      }
    }
  
    .back-link{
      position: fixed;
      bottom: 16px;
      top: auto;
      left: 16px;
      z-index: 1000;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(9, 14, 30, 0.72);
      border: 1px solid rgba(122,162,255,.45);
      color: #eef2ff;
      text-decoration: none;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .02em;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .back-link:hover{
      transform: translateY(-1px);
      border-color: rgba(122,162,255,.8);
      background: rgba(12, 18, 36, 0.9);
    }
  </style>
</head>

<body>

  <a class="back-link" href="index.html" aria-label="Back to games">← Back to games</a>
  <div class="wrap">
    <!-- LEFT -->
    <div class="card">
      <div class="head">
        <h1 class="title">Colored XOR <span class="badge">CMY XOR stamps</span></h1>
        <p class="sub">
          Goal: make <b>Your board</b> match the <b>Target</b> exactly (shape <i>and</i> color). You place tetromino stamps.
          Stamping uses <b>XOR</b> (toggle): stamping the same CMY color on a cell twice cancels it back.
          <br><br>
          <b>Color = 3-bit CMY state per cell.</b> Each cell stores three on/off bits: Cyan (C), Magenta (M), Yellow (Y).
          A stamp flips exactly <i>one</i> bit (C or M or Y) over its footprint.
          <br>
          - One bit on: pure C/M/Y<br>
          - Two bits on: mix (C+M, C+Y, M+Y)<br>
          - Three bits on (C+M+Y): shown as dark/black<br>
          - Zero bits: empty/paper<br><br>
          Overlaps matter because XOR flips bits: if a cell already has Cyan and you stamp Cyan again, Cyan turns off.
        </p>
      </div>

      <div class="body">
        <div class="row controlsRow" style="margin-top:2px;">
          <span class="chip">Difficulty
            <select id="diffSel">
              <option value="easy">Easy</option>
              <option value="medium" selected>Medium</option>
              <option value="hard">Hard</option>
              <option value="cruel">Cruel</option>
            </select>
          </span>

          <span class="chip">Grid
            <select id="sizeSel">
              <option value="8">8×8</option>
              <option value="10" selected>10×10</option>
              <option value="12">12×12</option>
            </select>
          </span>

          <button class="btn small" id="applyBtn">Apply</button>
        </div>

        <div class="stats">
          <div class="stat">
            <div class="k">Moves</div>
            <div class="v" id="movesOut">0</div>
          </div>
          <div class="stat">
            <div class="k">Move limit</div>
            <div class="v" id="limitOut">—</div>
          </div>
        </div>

        <div class="meter" title="Move budget (moves / limit)">
          <div class="bar" id="moveBar"></div>
        </div>

        <div class="legendTiny" id="limitExplain"></div>

        <div class="legendTiny">
          <b>Keyboard (only the essentials; no duplicates):</b><br>
          <span class="kbd">I O T S Z J L</span> pick a piece •
          <span class="kbd">R</span> rotate piece •
          <span class="kbd">1</span>/<span class="kbd">2</span>/<span class="kbd">3</span> choose Cyan/Magenta/Yellow •
          <span class="kbd">U</span> undo last stamp •
          <span class="kbd">Y</span> redo •
          <span class="kbd">H</span> toggle mismatch hints •
          <span class="kbd">C</span> check match status.<br>
          (No keyboard shortcuts for <i>Reset</i>, <i>New</i>, or <i>Solution</i> to avoid conflicts.)
        </div>
      </div>
    </div>

    <!-- RIGHT -->
    <div class="card">
      <div class="rightTop">
        <div class="status" id="status">Pick a piece (I/O/T/S/Z/J/L), pick a color (1/2/3), hover, click to stamp.</div>

        <div class="pillLine">
          <span class="pill2" id="mismatchOut">Mismatch: —</span>
          <span class="pill2" id="levelOut">Level: 1</span>
          <span class="pill2" id="recipeOut">Recipe: —</span>
          <button class="btn small good" id="checkBtn">Check</button>

          <div class="boardControls" aria-label="Board controls">
            <button class="btn small primary" id="newLevelBtn">New</button>
            <button class="btn small" id="resetBtn">Reset</button>
            <button class="btn small" id="hintBtnTop">Hints</button>
            <button class="btn small" id="solutionBtnTop">Solution</button>
          </div>
        </div>
      </div>

      <div class="boards">
        <div class="board">
          <div class="targetRow">
            <div class="targetStack">
              <div id="targetGrid" class="grid mini"></div>
              <div class="targetLabelRow">
                <div class="targetLabel">Target</div>
                <div class="mobileOptions" aria-label="Mobile options">
                  <button class="menuBtn" id="menuBtn" aria-haspopup="true" aria-expanded="false" aria-controls="menuPanel">☰</button>
                  <div class="menuPanel" id="menuPanel" role="menu" aria-hidden="true">
                    <button class="menuItem" data-action="new">New</button>
                    <button class="menuItem" data-action="reset">Reset</button>
                    <button class="menuItem" data-action="hints">Hints</button>
                    <button class="menuItem" data-action="solution">Solution</button>
                    <div class="menuSep"></div>
                    <button class="menuItem" data-action="easy">Difficulty: Easy</button>
                    <button class="menuItem" data-action="medium">Difficulty: Medium</button>
                    <button class="menuItem" data-action="hard">Difficulty: Hard</button>
                    <button class="menuItem" data-action="cruel">Difficulty: Cruel</button>
                    <div class="menuSep"></div>
                    <button class="menuItem" data-action="cb-on">Color-blind: On</button>
                    <button class="menuItem" data-action="cb-off">Color-blind: Off</button>
                    <div class="menuSep"></div>
                    <button class="menuItem" data-action="howto">How to play</button>
                    <button class="menuItem" data-action="history">History</button>
                  </div>
                </div>
              </div>
            </div>
            <div class="paletteWrap nearBoard" aria-label="Pieces">
              <div class="palette compact" id="palette"></div>
            </div>
          </div>
        </div>

        <div class="board">
          <div class="mobilePreview" aria-label="Controls">
            <button class="btn small" id="rotateBtn" aria-label="Rotate" title="Rotate">⟳</button>
            <button class="btn small" id="undoBtn" aria-label="Undo" title="Undo">←</button>
            <button class="btn small" id="redoBtn" aria-label="Redo" title="Redo">→</button>
            <div class="colorPicker" role="group" aria-label="Stamp color">
              <button class="colorBtn" data-bit="1" aria-label="Cyan"></button>
              <button class="colorBtn" data-bit="2" aria-label="Magenta"></button>
              <button class="colorBtn" data-bit="4" aria-label="Yellow"></button>
            </div>
          </div>
          <div class="gridWrap">
            <canvas id="solCanvas"></canvas>
            <div id="playGrid" class="grid"></div>
          </div>
      <div class="moveFooter" id="moveFooter">Moves: 0 / —</div>
    </div>
      </div>
      <div class="moveFooter" style="font-size:11px; opacity:.7; margin-top:6px; text-align:center;">Designed by nefinia</div>

      <div class="howtoModal" id="howtoModal" role="dialog" aria-modal="true" aria-label="How to play">
        <div class="howtoCard">
          <div class="howtoHead">
            <div>How to play</div>
            <button class="btn small" id="howtoClose" aria-label="Close">Close</button>
          </div>
          <div>
            Stamp tetrominoes to make <b>Your board</b> match the <b>Target</b> in shape and color.
            Each stamp flips exactly one CMY bit (XOR), so overlapping the same color cancels it.
            Tap to place, drag to move the shadow, rotate with ⟳.
          </div>
        </div>
      </div>

      <div class="howtoModal" id="historyModal" role="dialog" aria-modal="true" aria-label="History">
        <div class="howtoCard">
          <div class="howtoHead">
            <div>History</div>
            <button class="btn small" id="historyClose" aria-label="Close">Close</button>
          </div>
          <div class="historyList" id="historyList"></div>
          <div style="margin-top:10px; text-align:right;">
            <button class="btn small" id="historyClear">Clear</button>
          </div>
        </div>
      </div>

      <div class="footerHint">
      </div>
    </div>
  </div>

<script>
(() => {
  // Tetrominoes
  const PIECES = [
    { id: "I", cells: [[0,0],[1,0],[2,0],[3,0]] },
    { id: "O", cells: [[0,0],[1,0],[0,1],[1,1]] },
    { id: "T", cells: [[1,0],[0,1],[1,1],[2,1]] },
    { id: "S", cells: [[1,0],[2,0],[0,1],[1,1]] },
    { id: "Z", cells: [[0,0],[1,0],[1,1],[2,1]] },
    { id: "J", cells: [[0,0],[0,1],[1,1],[2,1]] },
    { id: "L", cells: [[2,0],[0,1],[1,1],[2,1]] },
  ];

  // Difficulty
  const DIFF = {
    easy:   { targetStamps: 5,  moveLimit: 999 },
    medium: { targetStamps: 9,  moveLimit: 999 },
    hard:   { targetStamps: 14, moveLimit: 999 },
    cruel:  { targetStamps: 20, moveLimit: 999 },
  };

  // 3-bit CMY XOR
  const BIT_C = 1; // cyan
  const BIT_M = 2; // magenta
  const BIT_Y = 4; // yellow

  // Display colors (readable visualization, not strict physical CMY optics)
  const COL = {
    paper: [244,247,251], // 000
    black: [72,50,30],    // 111 (dark brown for visibility)
    C: [0,210,255],
    M: [255,0,170],
    Y: [255,230,0]
  };

  function mix(bits){
    if(bits === 0) return COL.paper;
    if(bits === 7) return COL.black;
    if (bits === (BIT_C | BIT_Y)) return [0, 220, 80];   // vibrant green
    if (bits === (BIT_M | BIT_Y)) return [255, 140, 0];  // vibrant orange

    const picks = [];
    if(bits & BIT_C) picks.push(COL.C);
    if(bits & BIT_M) picks.push(COL.M);
    if(bits & BIT_Y) picks.push(COL.Y);

    let r=0,g=0,b=0;
    for(const c of picks){ r+=c[0]; g+=c[1]; b+=c[2]; }
    r = Math.round(r/picks.length);
    g = Math.round(g/picks.length);
    b = Math.round(b/picks.length);

    // Slight darken for 2-color mixes so they read distinctly as mixes
    if(picks.length === 2){
      r = Math.round(r*0.95);
      g = Math.round(g*0.95);
      b = Math.round(b*0.95);
    }
    return [r,g,b];
  }
  function rgb([r,g,b]){ return `rgb(${r},${g},${b})`; }
  function patternLayers(bits){
    const layers = [];
    if (bits & BIT_C) {
      layers.push("repeating-linear-gradient(90deg, rgba(0,0,0,.28) 0 2px, rgba(0,0,0,0) 2px 6px)");
    }
    if (bits & BIT_Y) {
      layers.push("repeating-linear-gradient(0deg, rgba(0,0,0,.28) 0 2px, rgba(0,0,0,0) 2px 6px)");
    }
    if (bits & BIT_M) {
      layers.push("radial-gradient(circle at center, rgba(0,0,0,.35) 0 1.6px, rgba(0,0,0,0) 1.6px 100%)");
    }
    return layers.join(", ");
  }

  // DOM
  const elPalette   = document.getElementById("palette");
  const elPlayGrid  = document.getElementById("playGrid");
  const elTargetGrid= document.getElementById("targetGrid");
  const elStatus    = document.getElementById("status");
  const elMoves     = document.getElementById("movesOut");
  const elLimit     = document.getElementById("limitOut");
  const elMismatch  = document.getElementById("mismatchOut");
  const elLevel     = document.getElementById("levelOut");
  const elRecipeOut = document.getElementById("recipeOut");
  const elMoveBar   = document.getElementById("moveBar");
  const elLimitExplain = document.getElementById("limitExplain");
  const elMenuBtn = document.getElementById("menuBtn");
  const elMenuPanel = document.getElementById("menuPanel");
  const elMenuItems = Array.from(document.querySelectorAll(".menuItem"));
  const elHowto = document.getElementById("howtoModal");
  const elHowtoClose = document.getElementById("howtoClose");
  const elHistory = document.getElementById("historyModal");
  const elHistoryList = document.getElementById("historyList");
  const elHistoryClose = document.getElementById("historyClose");
  const elHistoryClear = document.getElementById("historyClear");
  const elMoveFooter = document.getElementById("moveFooter");

  const elDiff      = document.getElementById("diffSel");
  const elSize      = document.getElementById("sizeSel");

  const elHintBtn   = document.getElementById("hintBtn");
  const elSolutionBtn = document.getElementById("solutionBtn");
  const elHintBtnTop = document.getElementById("hintBtnTop");
  const elSolutionBtnTop = document.getElementById("solutionBtnTop");

  const solCanvas = document.getElementById("solCanvas");
  const solCtx = solCanvas.getContext("2d");
  const colorButtons = Array.from(document.querySelectorAll(".colorBtn"));

  // State
  let N = 10;
  let level = 1;

  // boards are ints 0..7
  let play, target;
  let moves = 0;
  let moveLimit = DIFF.medium.moveLimit;

  let selectedPieceId = null;
  let rotation = 0;
  let hover = null;

  // Undo/redo stacks
  let history = [];   // undo stack
  let future = [];    // redo stack

  // Selected CMY bit for stamping
  let selectedBit = BIT_C;

  let hintsOn = false;
  let solutionOn = false;
  let gameStart = null;
  let gameSolved = false;
  let solutionAnimStep = 0;
  let solutionAnimTimer = null;
  let suppressClickUntil = 0;
  let touchMoved = false;
  let colorBlind = false;

  // Target recipe includes bit
  let targetRecipe = [];

  // Helpers
  function makeGrid(n, v=0){
    return Array.from({length:n}, () => Array.from({length:n}, () => v));
  }
  function rotateCells(cells, r){
    let out = cells.map(([x,y]) => [x,y]);
    for(let k=0;k<r;k++) out = out.map(([x,y]) => [y, -x]); // 90° cw
    const minX = Math.min(...out.map(c => c[0]));
    const minY = Math.min(...out.map(c => c[1]));
    return out.map(([x,y]) => [x - minX, y - minY]);
  }
  function getPiece(id){ return PIECES.find(p => p.id === id); }
  function currentCells(){
    if(!selectedPieceId) return [];
    return rotateCells(getPiece(selectedPieceId).cells, rotation);
  }
  function inBounds(x,y){ return x>=0 && y>=0 && x<N && y<N; }
  function canPlace(ax, ay, cells){
    for(const [dx,dy] of cells){
      const x=ax+dx, y=ay+dy;
      if(!inBounds(x,y)) return false;
    }
    return true;
  }
  function xorStamp(board, ax, ay, cells, bit){
    for(const [dx,dy] of cells){
      const x=ax+dx, y=ay+dy;
      board[y][x] = board[y][x] ^ bit;
    }
  }
  function mismatchCount(){
    let m=0;
    for(let y=0;y<N;y++) for(let x=0;x<N;x++){
      if(play[y][x] !== target[y][x]) m++;
    }
    return m;
  }

  // Palette render
  function renderPalette(){
    if (!elPalette) return;
    elPalette.innerHTML = "";
    for(const p of PIECES){
      const item = document.createElement("div");
      item.className = "piece" + (p.id === selectedPieceId ? " selected" : "");
      item.tabIndex = 0;

      const c = document.createElement("canvas");
      c.width = 64; c.height = 64;
      c.className = "thumb";

      const name = document.createElement("div");
      name.className = "name";
      name.textContent = p.id;

      item.appendChild(c);
      item.appendChild(name);

      item.addEventListener("click", () => {
        selectedPieceId = p.id;
        rotation = 0;
        renderPalette();
        updateHUD();
        renderGhost();
      });

      item.addEventListener("keydown", (e) => {
        if(e.key === "Enter" || e.key === " "){
          e.preventDefault();
          selectedPieceId = p.id;
          rotation = 0;
          renderPalette();
          updateHUD();
          renderGhost();
        }
      });

      elPalette.appendChild(item);
      const rot = (p.id === selectedPieceId) ? rotation : 0;
      drawThumb(c, p.cells, rot);
    }
    renderPreview();
  }

  function drawThumb(canvas, baseCells, rot=0){
    const ctx = canvas.getContext("2d");
    ctx.clearRect(0,0,canvas.width,canvas.height);
    ctx.fillStyle = "transparent";
    ctx.fillRect(0,0,canvas.width,canvas.height);

    const cells = rotateCells(baseCells,rot);

    // Draw inside a consistent 4x4 grid with margin, centered within the frame
    const grid = 4;
    const cellSize = Math.floor(Math.min(canvas.width, canvas.height) / 5);
    const gridPx = cellSize * grid;
    const ox = Math.floor((canvas.width - gridPx) / 2);
    const oy = Math.floor((canvas.height - gridPx) / 2);
    const maxX = Math.max(...cells.map(c => c[0]));
    const maxY = Math.max(...cells.map(c => c[1]));
    const w = maxX + 1;
    const h = maxY + 1;
    const offX = Math.floor((grid - w) / 2);
    const offY = Math.floor((grid - h) / 2);

    ctx.fillStyle = rgb(mix(selectedBit));
    for(const [x,y] of cells){
      ctx.fillRect(ox + (x + offX)*cellSize, oy + (y + offY)*cellSize, cellSize-1, cellSize-1);
    }

    if (colorBlind && selectedBit) {
      ctx.save();
      ctx.globalCompositeOperation = "source-atop";
      ctx.fillStyle = "rgba(0,0,0,0)";
      ctx.restore();
      ctx.save();
      const patternCanvas = document.createElement("canvas");
      patternCanvas.width = Math.max(6, Math.round(cellSize * 1.0));
      patternCanvas.height = patternCanvas.width;
      const pctx = patternCanvas.getContext("2d");
      pctx.clearRect(0,0,patternCanvas.width,patternCanvas.height);
      pctx.fillStyle = "transparent";
      const patternSize = patternCanvas.width;
      const drawPattern = (bits) => {
        pctx.clearRect(0,0,patternSize,patternSize);
        if (bits & BIT_C) {
          pctx.strokeStyle = "rgba(0,0,0,.28)";
          pctx.lineWidth = 2;
          for (let x = 0; x <= patternSize; x += 6) {
            pctx.beginPath();
            pctx.moveTo(x, 0);
            pctx.lineTo(x, patternSize);
            pctx.stroke();
          }
        }
        if (bits & BIT_Y) {
          pctx.strokeStyle = "rgba(0,0,0,.28)";
          pctx.lineWidth = 2;
          for (let y = 0; y <= patternSize; y += 6) {
            pctx.beginPath();
            pctx.moveTo(0, y);
            pctx.lineTo(patternSize, y);
            pctx.stroke();
          }
        }
      };
      const patternBits = selectedBit & ~BIT_M;
      drawPattern(patternBits);
      const pattern = ctx.createPattern(patternCanvas, "repeat");
      ctx.fillStyle = pattern;
      for(const [x,y] of cells){
        ctx.fillRect(ox + (x + offX)*cellSize, oy + (y + offY)*cellSize, cellSize-1, cellSize-1);
      }
      ctx.restore();
    }
    if (colorBlind && (selectedBit & BIT_M)) {
      ctx.save();
      ctx.fillStyle = "rgba(0,0,0,.35)";
      const dotR = Math.max(1.2, Math.round(cellSize * 0.12));
      for (const [x,y] of cells) {
        const cx = ox + (x + offX) * cellSize + Math.floor(cellSize / 2);
        const cy = oy + (y + offY) * cellSize + Math.floor(cellSize / 2);
        ctx.beginPath();
        ctx.arc(cx, cy, dotR, 0, Math.PI * 2);
        ctx.fill();
      }
      ctx.restore();
    }
  }

  function renderPreview(){}

  function renderColorButtons(){
    if (!colorButtons.length) return;
    colorButtons.forEach((btn) => {
      const bit = Number(btn.dataset.bit);
      const col = (bit === BIT_C) ? COL.C : (bit === BIT_M) ? COL.M : COL.Y;
      btn.style.background = rgb(col);
      btn.classList.toggle("sel", selectedBit === bit);
    });
  }

  // Grids
  function renderGrid(el, board, mini=false){
    el.innerHTML = "";
    el.style.gridTemplateColumns = `repeat(${N}, ${mini ? "var(--cellMini)" : "var(--cell)"})`;
    if (!mini) el.style.setProperty("--n", N);

    for(let y=0;y<N;y++){
      for(let x=0;x<N;x++){
        const d = document.createElement("div");
        d.className = "cell";
        d.dataset.x = x;
        d.dataset.y = y;

        const bits = board[y][x];
        d.style.background = rgb(mix(bits));
        if (colorBlind && bits) {
          const pat = patternLayers(bits);
          d.style.backgroundImage = pat;
          d.style.backgroundSize = mini ? "6px 6px" : "8px 8px";
          d.style.backgroundPosition = "center";
        } else {
          d.style.backgroundImage = "none";
        }
        if(bits !== 0){
          d.style.boxShadow = "inset 0 0 0 1px rgba(255,255,255,.14)";
        }

        if(!mini && hintsOn){
          if(play[y][x] !== target[y][x]) d.classList.add("mismatch");
        }

        el.appendChild(d);
      }
    }
  }

  // Ghost preview
  function clearGhost(){
    elPlayGrid.querySelectorAll(".cell.ghost").forEach(c => c.classList.remove("ghost","bad"));
  }
  function renderGhost(){
    clearGhost();
    if(!selectedPieceId || !hover) return;

    const cells = currentCells();
    const ok = canPlace(hover.x, hover.y, cells);

    for(const [dx,dy] of cells){
      const x=hover.x+dx, y=hover.y+dy;
      if(!inBounds(x,y)) continue;
      const idx = y*N + x;
      const cellEl = elPlayGrid.children[idx];
      cellEl.classList.add("ghost");
      if(!ok) cellEl.classList.add("bad");
    }
  }

  // Solution overlay
  function resizeSolCanvasToGrid(){
    const rect = elPlayGrid.getBoundingClientRect();
    const wrapRect = elPlayGrid.parentElement.getBoundingClientRect();
    solCanvas.width = Math.round(rect.width * devicePixelRatio);
    solCanvas.height = Math.round(rect.height * devicePixelRatio);
    solCanvas.style.width = rect.width + "px";
    solCanvas.style.height = rect.height + "px";
    solCanvas.style.left = Math.round(rect.left - wrapRect.left) + "px";
    solCanvas.style.top = Math.round(rect.top - wrapRect.top) + "px";
    solCanvas.style.right = "auto";
    solCanvas.style.bottom = "auto";
    solCtx.setTransform(devicePixelRatio, 0, 0, devicePixelRatio, 0, 0);
  }

  function drawPolyominoOutline(ctx, step, cells, cellElAt, gridRect, cellW, cellH) {
    const set = new Set(cells.map(([dx, dy]) => `${step.x + dx},${step.y + dy}`));
    ctx.beginPath();
    for (const [dx, dy] of cells) {
      const gx = step.x + dx;
      const gy = step.y + dy;
      const el = cellElAt(gx, gy);
      if (!el) continue;

      const r = el.getBoundingClientRect();
      const px = r.left - gridRect.left;
      const py = r.top  - gridRect.top;

      if (!set.has(`${gx},${gy - 1}`)) { ctx.moveTo(px, py); ctx.lineTo(px + cellW, py); }
      if (!set.has(`${gx + 1},${gy}`)) { ctx.moveTo(px + cellW, py); ctx.lineTo(px + cellW, py + cellH); }
      if (!set.has(`${gx},${gy + 1}`)) { ctx.moveTo(px, py + cellH); ctx.lineTo(px + cellW, py + cellH); }
      if (!set.has(`${gx - 1},${gy}`)) { ctx.moveTo(px, py); ctx.lineTo(px, py + cellH); }
    }
    ctx.stroke();
  }

  function drawSolutionOverlay(){
    resizeSolCanvasToGrid();
    solCtx.clearRect(0,0, solCanvas.width, solCanvas.height);
    if(!solutionOn) return;

    const cell0 = elPlayGrid.querySelector(".cell");
    if(!cell0) return;

    const cellRect = cell0.getBoundingClientRect();
    const gridRect = elPlayGrid.getBoundingClientRect();
    const cellW = cellRect.width;
    const cellH = cellRect.height;

    const cellElAt = (x,y) => elPlayGrid.children[y*N + x];

    solCtx.save();
    solCtx.globalCompositeOperation = "multiply";

    const maxSteps = targetRecipe.length;
    const darken = (col, f=0.2) => {
      const m = col.match(/\d+/g).map(Number);
      const r = Math.max(0, Math.round(m[0] * f));
      const g = Math.max(0, Math.round(m[1] * f));
      const b = Math.max(0, Math.round(m[2] * f));
      return `rgb(${r},${g},${b})`;
    };
    const lighten = (col, f=0.2) => {
      const m = col.match(/\d+/g).map(Number);
      const r = Math.min(255, Math.round(m[0] + (255 - m[0]) * f));
      const g = Math.min(255, Math.round(m[1] + (255 - m[1]) * f));
      const b = Math.min(255, Math.round(m[2] + (255 - m[2]) * f));
      return `rgb(${r},${g},${b})`;
    };

    function labelPosForCell(cellRect, cornerIdx){
      const pad = 1;
      const left = Math.round(cellRect.left - gridRect.left);
      const top = Math.round(cellRect.top - gridRect.top);
      const right = left + Math.round(cellRect.width);
      const bottom = top + Math.round(cellRect.height);
      if (cornerIdx === 4) return { x: Math.round((left + right) / 2), y: Math.round((top + bottom) / 2), align: "center", baseline: "middle" }; // center
      if (cornerIdx === 0) return { x: left + pad, y: top + pad, align: "left", baseline: "top" }; // top-left
      if (cornerIdx === 1) return { x: right - pad, y: top + pad, align: "right", baseline: "top" }; // top-right
      if (cornerIdx === 2) return { x: right - pad, y: bottom - pad, align: "right", baseline: "bottom" }; // bottom-right
      return { x: left + pad, y: bottom - pad, align: "left", baseline: "bottom" }; // bottom-left
    }

    const steps = targetRecipe.slice(0, maxSteps);
    const usedLabelSlots = new Set();

    solCtx.globalCompositeOperation = "multiply";
    solCtx.globalAlpha = 0.35;
    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      const p = getPiece(step.pieceId);
      const cells = rotateCells(p.cells, step.rot);
      const col = rgb(mix(step.bit));
      solCtx.fillStyle = col;
      for (const [dx, dy] of cells) {
        const x = step.x + dx;
        const y = step.y + dy;
        if (!inBounds(x,y)) continue;
        const el = cellElAt(x,y);
        if (!el) continue;
        const r = el.getBoundingClientRect();
        const px = Math.round(r.left - gridRect.left);
        const py = Math.round(r.top  - gridRect.top);
        const cw = Math.round(r.width);
        const ch = Math.round(r.height);
        solCtx.fillRect(px, py, cw, ch);
      }
    }

    solCtx.globalAlpha = 1;
    solCtx.globalCompositeOperation = "source-over";
    for (let i = 0; i < steps.length; i++) {
      const step = steps[i];
      const p = getPiece(step.pieceId);
      const cells = rotateCells(p.cells, step.rot);
      const col = rgb(mix(step.bit));
      const labelColor = (() => {
        const m = col.match(/\d+/g).map(Number);
        const r = m[0], g = m[1], b = m[2];
        if (r > 170 && b > 170 && g < 120) return lighten(col, 0.6); // magenta
        return col;
      })();

      let cornerIdx = 4;
      let bestConflicts = Infinity;
      const cornerOrder = [4, 0, 1, 2, 3];
      for (const c of cornerOrder) {
        let conflicts = 0;
        for (const [dx, dy] of cells) {
          const gx = step.x + dx;
          const gy = step.y + dy;
          const key = `${gx},${gy},${c}`;
          if (usedLabelSlots.has(key)) conflicts++;
        }
        if (conflicts < bestConflicts) {
          bestConflicts = conflicts;
          cornerIdx = c;
        }
      }

      for (const [dx, dy] of cells) {
        const gx = step.x + dx;
        const gy = step.y + dy;
        usedLabelSlots.add(`${gx},${gy},${cornerIdx}`);
      }
      for (const [dx, dy] of cells) {
        const gx = step.x + dx;
        const gy = step.y + dy;
        const el = cellElAt(gx, gy);
        if (!el) continue;
        const r = el.getBoundingClientRect();
        const pos = labelPosForCell(r, cornerIdx);
        const label = String(i+1);
        solCtx.shadowColor = "transparent";
        solCtx.shadowBlur = 0;
        solCtx.shadowOffsetX = 0;
        solCtx.shadowOffsetY = 0;
        solCtx.textAlign = pos.align;
        solCtx.textBaseline = pos.baseline;
        solCtx.font = "900 9px system-ui, -apple-system, Segoe UI, Roboto, Arial";
        solCtx.lineWidth = 1;
        solCtx.lineJoin = "round";
        solCtx.strokeStyle = "#000000";
        solCtx.strokeText(label, pos.x, pos.y);
        solCtx.fillStyle = labelColor;
        solCtx.fillText(label, pos.x, pos.y);
      }
    }

    solCtx.restore();
  }

  // HUD
  function updateHUD(message) {
    const mm = mismatchCount();

    elMoves.textContent = String(moves);
    elLimit.textContent = (moveLimit >= 999) ? "—" : String(moveLimit);
    elLevel.textContent = `Level: ${level}`;
    elMismatch.textContent = `Mismatch: ${mm}`;
    elRecipeOut.textContent = `Recipe: ${targetRecipe.length}`;

    elMismatch.classList.remove("ok", "bad");
    if (mm === 0) elMismatch.classList.add("ok");
    else if (moveLimit < 999 && moves >= moveLimit) elMismatch.classList.add("bad");

    if (moveLimit >= 999) {
      elMoveBar.style.width = "0%";
      elLimitExplain.textContent = "Move limit is off.";
      if (elMoveFooter) elMoveFooter.textContent = `Moves: ${moves}`;
    } else {
      const pct = Math.min(100, Math.round((moves / moveLimit) * 100));
      elMoveBar.style.width = pct + "%";
      elLimitExplain.textContent =
        `Move budget: ${moves}/${moveLimit}. Matching the target is the real objective.`;
      if (elMoveFooter) elMoveFooter.textContent = `Moves: ${moves} / ${moveLimit}`;
    }

    if (elMoveFooter) {
      elMoveFooter.classList.toggle("solved", mm === 0);
      if (mm === 0) {
        elMoveFooter.textContent = `Solved! Perfect match in ${moves} moves.`;
        if (!gameSolved) gameSolved = true;
      }
    }

    if (message) { elStatus.textContent = message; return; }

    const bitName = (selectedBit === BIT_C) ? "Cyan" : (selectedBit === BIT_M) ? "Magenta" : "Yellow";
    if (!selectedPieceId) {
      elStatus.textContent =
        "Keys: I/O/T/S/Z/J/L pick piece • 1/2/3 pick Cyan/Magenta/Yellow • R rotate • Hover + click to stamp.";
    } else {
      elStatus.textContent =
        `Piece: ${selectedPieceId} • Rotation: ${rotation*90}° • Stamp color: ${bitName} • Undo(U) • Redo(Y) • Hints(H) • Check(C).`;
    }
  }

  // Target generation
  function randBit(){
    const r = Math.floor(Math.random()*3);
    return r===0 ? BIT_C : r===1 ? BIT_M : BIT_Y;
  }

  function generateTargetWithRecipe(diffKey) {
    const { targetStamps } = DIFF[diffKey];
    const t = makeGrid(N, 0);
    const recipe = [];

    for (let i = 0; i < targetStamps; i++) {
      const p = PIECES[Math.floor(Math.random() * PIECES.length)];
      const rot = Math.floor(Math.random() * 4);
      const bit = randBit();
      const cells = rotateCells(p.cells, rot);

      let placed = false;
      for (let tries = 0; tries < 160; tries++) {
        const ax = Math.floor(Math.random() * N);
        const ay = Math.floor(Math.random() * N);
        if (canPlace(ax, ay, cells)) {
          xorStamp(t, ax, ay, cells, bit);
          recipe.push({ pieceId: p.id, rot, x: ax, y: ay, bit });
          placed = true;
          break;
        }
      }
      if (!placed) i--;
    }
    return { t, recipe };
  }

  function rerenderAll() {
    renderGrid(elTargetGrid, target, true);
    renderGrid(elPlayGrid, play, false);
    fitPlayGrid();
    renderGhost();

    solCanvas.classList.toggle("on", solutionOn);
    drawSolutionOverlay();

    // enable/disable undo/redo buttons
    document.getElementById("undoBtn").disabled = history.length === 0;
    document.getElementById("redoBtn").disabled = future.length === 0;

    updateHUD();
    renderPalette();
    renderColorButtons();
  }

  // Game flow
  function startLevel(newLevel = false) {
    finalizeGame();
    if (newLevel) level++;

    const d = elDiff.value;
    moveLimit = DIFF[d].moveLimit;

    const out = generateTargetWithRecipe(d);
    target = out.t;
    targetRecipe = out.recipe;

    play = makeGrid(N, 0);
    moves = 0;
    gameStart = Date.now();
    gameSolved = false;
    history = [];
    future = [];
    hover = null;

    // solution default off
    solutionOn = false;
    if (elSolutionBtn) {
      elSolutionBtn.classList.remove("toggled");
      elSolutionBtn.textContent = "Show solution";
    }
    if (elSolutionBtnTop) {
      elSolutionBtnTop.classList.remove("toggled");
      elSolutionBtnTop.textContent = "Solution";
    }

    rerenderAll();
  }

  function stampAt(ax, ay) {
    if (!selectedPieceId) return;

    const cells = currentCells();
    if (!canPlace(ax, ay, cells)) {
      updateHUD("Out of bounds — keep the whole piece inside the grid.");
      setTimeout(() => updateHUD(), 800);
      return;
    }

    xorStamp(play, ax, ay, cells, selectedBit);
    history.push({ pieceId: selectedPieceId, rot: rotation, x: ax, y: ay, bit: selectedBit });
    future = []; // new action invalidates redo
    moves++;

    rerenderAll();

    const mm = mismatchCount();
    if (mm === 0) updateHUD(`Matched. Moves: ${moves}.`);
  }

  function undo() {
    const last = history.pop();
    if (!last) return;

    const cells = rotateCells(getPiece(last.pieceId).cells, last.rot);
    xorStamp(play, last.x, last.y, cells, last.bit); // XOR again to revert
    moves = Math.max(0, moves - 1);
    future.push(last);

    rerenderAll();
  }

  function redo() {
    const step = future.pop();
    if (!step) return;

    const cells = rotateCells(getPiece(step.pieceId).cells, step.rot);
    xorStamp(play, step.x, step.y, cells, step.bit);
    moves++;
    history.push(step);

    rerenderAll();
  }

  function reset() {
    play = makeGrid(N, 0);
    moves = 0;
    gameSolved = false;
    history = [];
    future = [];
    hover = null;
    rerenderAll();
  }

  function rotateSelected() {
    if (!selectedPieceId) return;
    rotation = (rotation + 3) % 4;
    updateHUD();
    renderGhost();
    renderPalette();
  }

  function applySettings() {
    N = 8;
    if (elSize) elSize.value = "8";
    play = makeGrid(N, 0);
    target = makeGrid(N, 0);
    moves = 0;
    history = [];
    future = [];
    hover = null;
    level = 1;
    gameSolved = false;

    solutionOn = false;
    hintsOn = false;
    if (elHintBtn) elHintBtn.classList.remove("toggled");
    if (elHintBtnTop) elHintBtnTop.classList.remove("toggled");
    if (elSolutionBtn) {
      elSolutionBtn.classList.remove("toggled");
      elSolutionBtn.textContent = "Show solution";
    }
    if (elSolutionBtnTop) {
      elSolutionBtnTop.classList.remove("toggled");
      elSolutionBtnTop.textContent = "Solution";
    }

    renderPalette();
    startLevel(false);

    setTimeout(() => { if (solutionOn) drawSolutionOverlay(); }, 0);
  }

  function toggleHints() {
    hintsOn = !hintsOn;
    if (elHintBtn) elHintBtn.classList.toggle("toggled", hintsOn);
    if (elHintBtnTop) elHintBtnTop.classList.toggle("toggled", hintsOn);
    rerenderAll();
    updateHUD(hintsOn
      ? "Hints ON: red outlines mark cells where your board differs from the target."
      : "Hints OFF.");
    setTimeout(() => updateHUD(), 900);
  }

  function toggleSolution() {
    solutionOn = !solutionOn;
    if (elSolutionBtn) elSolutionBtn.classList.toggle("toggled", solutionOn);
    if (elSolutionBtnTop) elSolutionBtnTop.classList.toggle("toggled", solutionOn);
    if (elSolutionBtn) elSolutionBtn.textContent = solutionOn ? "Hide solution" : "Show solution";
    if (elSolutionBtnTop) elSolutionBtnTop.textContent = solutionOn ? "Hide solution" : "Solution";
    if (solutionOn) startSolutionAnim();
    else stopSolutionAnim();
    rerenderAll();
  }

  function startSolutionAnim() {
    stopSolutionAnim();
    solutionAnimStep = 0;
    solutionAnimTimer = setInterval(() => {
      solutionAnimStep++;
      if (solutionAnimStep > targetRecipe.length) {
        stopSolutionAnim();
        return;
      }
      drawSolutionOverlay();
    }, 220);
  }

  function stopSolutionAnim() {
    if (solutionAnimTimer) {
      clearInterval(solutionAnimTimer);
      solutionAnimTimer = null;
    }
  }

  // Events (mouse)
  elPlayGrid.addEventListener("mousemove", (e) => {
    const cell = e.target.closest(".cell");
    if (!cell) return;
    hover = { x: Number(cell.dataset.x), y: Number(cell.dataset.y) };
    renderGhost();
  });
  elPlayGrid.addEventListener("mouseleave", () => {
    hover = null;
    clearGhost();
  });
  elPlayGrid.addEventListener("click", (e) => {
    if (Date.now() < suppressClickUntil) return;
    const cell = e.target.closest(".cell");
    if (!cell) return;
    stampAt(Number(cell.dataset.x), Number(cell.dataset.y));
  });

  function updateHoverFromPoint(clientX, clientY){
    const cell = document.elementFromPoint(clientX, clientY);
    const hit = cell && cell.closest && cell.closest(".cell");
    if (hit) {
      hover = { x: Number(hit.dataset.x), y: Number(hit.dataset.y) };
      renderGhost();
      return true;
    }
    return false;
  }

  elPlayGrid.addEventListener("touchstart", (e) => {
    if (e.touches.length !== 1) return;
    touchMoved = false;
  }, { passive: true });

  elPlayGrid.addEventListener("touchmove", (e) => {
    if (e.touches.length !== 1) return;
    const touch = e.touches[0];
    updateHoverFromPoint(touch.clientX, touch.clientY);
    touchMoved = true;
  }, { passive: true });

  elPlayGrid.addEventListener("touchend", (e) => {
    if (e.changedTouches.length !== 1) return;
    if (!touchMoved && hover) {
      stampAt(hover.x, hover.y);
      suppressClickUntil = Date.now() + 350;
    }
  }, { passive: true });

  // Buttons
  document.getElementById("newLevelBtn").addEventListener("click", () => startLevel(true));
  document.getElementById("resetBtn").addEventListener("click", reset);
  document.getElementById("undoBtn").addEventListener("click", undo);
  document.getElementById("redoBtn").addEventListener("click", redo);
  document.getElementById("rotateBtn").addEventListener("click", rotateSelected);
  document.getElementById("applyBtn").addEventListener("click", applySettings);
  function runMenuAction(action){
    if (!action) return;
    if (action === "new") startLevel(true);
    if (action === "reset") reset();
    if (action === "hints") toggleHints();
    if (action === "solution") toggleSolution();
    if (action === "cb-on") { colorBlind = true; rerenderAll(); }
    if (action === "cb-off") { colorBlind = false; rerenderAll(); }
    if (action === "howto" && elHowto) elHowto.classList.add("on");
    if (action === "history" && elHistory) { renderHistory(); elHistory.classList.add("on"); }
    if (["easy","medium","hard","cruel"].includes(action)) {
      elDiff.value = action;
      applySettings();
    }
  }

  function closeMenu(){
    if (!elMenuPanel || !elMenuBtn) return;
    elMenuPanel.classList.remove("on");
    elMenuPanel.setAttribute("aria-hidden", "true");
    elMenuBtn.setAttribute("aria-expanded", "false");
  }

  function toggleMenu(){
    if (!elMenuPanel || !elMenuBtn) return;
    const open = elMenuPanel.classList.toggle("on");
    elMenuPanel.setAttribute("aria-hidden", open ? "false" : "true");
    elMenuBtn.setAttribute("aria-expanded", open ? "true" : "false");
  }

  if (elMenuBtn && elMenuPanel) {
    elMenuBtn.addEventListener("click", (e) => {
      e.stopPropagation();
      toggleMenu();
    });
    elMenuItems.forEach((btn) => {
      btn.addEventListener("click", () => {
        runMenuAction(btn.dataset.action);
        closeMenu();
      });
    });
    document.addEventListener("click", (e) => {
      if (!elMenuPanel.classList.contains("on")) return;
      if (elMenuPanel.contains(e.target) || elMenuBtn.contains(e.target)) return;
      closeMenu();
    });
  }
  if (elHowtoClose && elHowto) {
    elHowtoClose.addEventListener("click", () => elHowto.classList.remove("on"));
    elHowto.addEventListener("click", (e) => {
      if (e.target === elHowto) elHowto.classList.remove("on");
    });
  }
  if (elHistoryClose && elHistory) {
    elHistoryClose.addEventListener("click", () => elHistory.classList.remove("on"));
    elHistory.addEventListener("click", (e) => {
      if (e.target === elHistory) elHistory.classList.remove("on");
    });
  }
  if (elHistoryClear) {
    elHistoryClear.addEventListener("click", () => {
      localStorage.removeItem("mixor_history");
      renderHistory();
    });
  }

  if (elHintBtn) elHintBtn.addEventListener("click", toggleHints);
  if (elSolutionBtn) elSolutionBtn.addEventListener("click", toggleSolution);
  if (elHintBtnTop) elHintBtnTop.addEventListener("click", toggleHints);
  if (elSolutionBtnTop) elSolutionBtnTop.addEventListener("click", toggleSolution);

  document.getElementById("checkBtn").addEventListener("click", () => {
    const mm = mismatchCount();
    if (mm === 0) updateHUD(`Matched. Moves: ${moves}.`);
    else updateHUD(`Not matched yet. Mismatch: ${mm}. (Hints: press H)`);
    setTimeout(() => updateHUD(), 1100);
  });

  colorButtons.forEach((btn) => {
    btn.addEventListener("click", () => {
      selectedBit = Number(btn.dataset.bit);
      renderPalette();
      updateHUD();
      renderGhost();
      renderPreview();
      renderColorButtons();
    });
  });

  // Keyboard: ONLY essentials, no duplicates, no Ctrl/Cmd shortcuts.
  document.addEventListener("keydown", (e) => {
    const tag = (document.activeElement && document.activeElement.tagName) || "";
    if (tag === "SELECT" || tag === "INPUT" || tag === "TEXTAREA") return;

    // User request: do not use Ctrl/Cmd/Alt bindings at all
    if (e.ctrlKey || e.metaKey || e.altKey) return;

    const k = e.key;
    const upper = k.toUpperCase();

    // Piece select: exactly I O T S Z J L
    if (["I","O","T","S","Z","J","L"].includes(upper)) {
      selectedPieceId = upper;
      rotation = 0;
      renderPalette();
      updateHUD(`Selected piece ${upper}. (Rotate: R)`);
      renderGhost();
      return;
    }

    // Rotate
    if (upper === "R") { rotateSelected(); return; }

    // Colors
    if (k === "1") { selectedBit = BIT_C; renderPalette(); updateHUD("Stamp color: Cyan (C bit)."); renderGhost(); renderColorButtons(); return; }
    if (k === "2") { selectedBit = BIT_M; renderPalette(); updateHUD("Stamp color: Magenta (M bit)."); renderGhost(); renderColorButtons(); return; }
    if (k === "3") { selectedBit = BIT_Y; renderPalette(); updateHUD("Stamp color: Yellow (Y bit)."); renderGhost(); renderColorButtons(); return; }

    // Undo / Redo
    if (upper === "U") { undo(); updateHUD("Undo."); setTimeout(() => updateHUD(), 500); return; }
    if (upper === "Y") { redo(); updateHUD("Redo."); setTimeout(() => updateHUD(), 500); return; }

    // Hints / Check
    if (upper === "H") { toggleHints(); return; }
    if (upper === "C") { document.getElementById("checkBtn").click(); return; }

    // Intentionally: no keyboard shortcuts for reset/new/solution
  });

  window.addEventListener("resize", () => {
    fitPlayGrid();
    if (solutionOn) drawSolutionOverlay();
  });

  function fitPlayGrid(){
    if (!elPlayGrid) return;
    const wrap = elPlayGrid.parentElement;
    if (!wrap) return;
    const cs = getComputedStyle(elPlayGrid);
    const pad = parseFloat(cs.paddingLeft) || 0;
    const gap = parseFloat(cs.gap) || 0;
    const wrapStyle = getComputedStyle(wrap);
    const wrapPad = (parseFloat(wrapStyle.paddingLeft) || 0) + (parseFloat(wrapStyle.paddingRight) || 0);
    const viewport = Math.min(window.innerWidth, document.documentElement.clientWidth || window.innerWidth);
    const width = Math.min(wrap.clientWidth, viewport);
    const n = N || 10;
    if (width <= 0 || n <= 0) return;
    const cell = Math.floor((width - (n - 1) * gap) / n);
    const isNarrow = true;
    const minCell = 10;
    const clamped = Math.max(minCell, cell);
    elPlayGrid.style.setProperty("--cell", clamped + "px");
    elPlayGrid.style.transform = "none";
    wrap.style.height = "auto";
  }

  // Init
  function init() {
    elSize.value = "8";
    N = 8;
    renderPalette();
    startLevel(false);
  }
  init();

  function finalizeGame(){
    if (!gameStart) return;
    if (moves === 0) return;
    const entry = {
      time: new Date().toISOString(),
      difficulty: elDiff.value,
      size: N,
      moves,
      solved: gameSolved,
      durationSec: Math.round((Date.now() - gameStart) / 1000)
    };
    const list = JSON.parse(localStorage.getItem("mixor_history") || "[]");
    list.unshift(entry);
    while (list.length > 30) list.pop();
    localStorage.setItem("mixor_history", JSON.stringify(list));
  }

  function renderHistory(){
    if (!elHistoryList) return;
    const list = JSON.parse(localStorage.getItem("mixor_history") || "[]");
    if (!list.length) {
      elHistoryList.innerHTML = "<div class=\"meta\">No games yet.</div>";
      return;
    }
    elHistoryList.innerHTML = "";
    list.forEach((g) => {
      const item = document.createElement("div");
      item.className = "historyItem";
      const left = document.createElement("div");
      left.innerHTML = `<div><b>${g.solved ? "Solved" : "Unsolved"}</b> · ${g.moves} moves</div><div class="meta">${g.difficulty} · ${g.size}x${g.size} · ${g.durationSec}s</div>`;
      const right = document.createElement("div");
      right.className = "meta";
      const d = new Date(g.time);
      right.textContent = d.toLocaleDateString();
      item.appendChild(left);
      item.appendChild(right);
      elHistoryList.appendChild(item);
    });
  }
})();
</script>
</body>
</html>
