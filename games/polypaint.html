<!doctype html>
<html lang="en">
<head>
<meta charset="utf-8" />
<meta name="viewport" content="width=device-width,initial-scale=1" />
<title>PolyClear Duel — Pass Match + Bigger Piece Set + Bot</title>
<style>
  :root{
    --bg:#0b1020;
    --panel:#121a33;
    --border:rgba(255,255,255,.10);
    --text:#eef2ff;
    --muted:#aab3d6;
    --p1:#ff5a7a;
    --p2:#4dd3ff;
    --empty:#1a2446;
    --grid:#20305a;
    --gridBold:#3b4c8a;
    --shadow: 0 12px 30px rgba(0,0,0,.35);
  }
  *{ box-sizing:border-box; }
  body{
    margin:0;
    padding:16px;
    background:radial-gradient(900px 600px at 20% 0%, #18265a 0%, var(--bg) 55%);
    color:var(--text);
    font-family:system-ui, -apple-system, Segoe UI, Roboto, Ubuntu, Cantarell, "Noto Sans", sans-serif;
    display:flex;
    justify-content:center;
  }
  .wrap{
    width:min(1100px, 100%);
    display:grid;
    grid-template-columns: 1fr 360px;
    gap:14px;
    align-items:start;
  }
  .card{
    background:linear-gradient(180deg, rgba(255,255,255,.05), rgba(255,255,255,.02));
    border:1px solid var(--border);
    border-radius:18px;
    box-shadow:var(--shadow);
    overflow:hidden;
  }
  .hd{
    padding:14px 14px 10px;
    border-bottom:1px solid rgba(255,255,255,.08);
    display:flex;
    justify-content:space-between;
    gap:10px;
    align-items:flex-start;
  }
  .title{ font-weight:800; font-size:16px; letter-spacing:.2px; }
  .sub{ margin-top:2px; font-size:12px; color:var(--muted); line-height:1.3; }
  .body{ padding:14px; }
  canvas{ display:block; width:100%; height:auto; }
  .row{ display:flex; gap:10px; flex-wrap:wrap; align-items:center; }
  button, select{
    background:rgba(255,255,255,.06);
    color:var(--text);
    border:1px solid rgba(255,255,255,.12);
    border-radius:12px;
    padding:9px 10px;
    font-weight:700;
    cursor:pointer;
  }
  button:hover{ background:rgba(255,255,255,.10); }
  button:disabled{ opacity:.5; cursor:not-allowed; }
  .pill{
    display:inline-flex;
    align-items:center;
    gap:8px;
    padding:7px 10px;
    border-radius:999px;
    border:1px solid rgba(255,255,255,.12);
    background:rgba(0,0,0,.18);
    font-size:12px;
    color:var(--muted);
    white-space:nowrap;
  }
  .dot{
    width:10px; height:10px; border-radius:50%;
    background:var(--empty);
    border:1px solid rgba(255,255,255,.15);
  }
  .dot.p1{ background:var(--p1); }
  .dot.p2{ background:var(--p2); }
  .kv{
    display:grid;
    grid-template-columns: 1fr auto;
    gap:8px 10px;
    font-size:13px;
    color:var(--muted);
  }
  .kv b{ color:var(--text); }
  .scoreBox{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(0,0,0,.18);
  }
  .scoreLine{
    display:flex; justify-content:space-between; align-items:baseline;
    font-size:13px; color:var(--muted);
    margin-top:6px;
  }
  .scoreLine:first-child{ margin-top:0; }
  .scoreLine b{ color:var(--text); font-size:18px; }
  .banner{
    padding:10px 12px;
    border-radius:14px;
    border:1px solid rgba(255,255,255,.10);
    background:rgba(255,255,255,.04);
    font-weight:800;
    line-height:1.25;
  }
  .banner.p1{ border-color: rgba(255,90,122,.45); }
  .banner.p2{ border-color: rgba(77,211,255,.45); }
  .banner.tie{ border-color: rgba(255,255,255,.18); }

  .pool{
    display:grid;
    grid-template-columns: 1fr 1fr 1fr;
    gap:10px;
  }
  .poolItem{
    border:1px solid rgba(255,255,255,.10);
    border-radius:14px;
    background:rgba(0,0,0,.16);
    padding:8px;
    cursor:pointer;
    position:relative;
  }
  .poolItem.selected{
    outline:2px solid rgba(255,255,255,.30);
  }
  .poolItem canvas{
    width:100%;
    height:auto;
    border-radius:10px;
    background:rgba(0,0,0,.12);
  }
  .tag{
    position:absolute;
    top:6px; left:6px;
    font-size:11px;
    padding:3px 7px;
    border-radius:999px;
    background:rgba(0,0,0,.35);
    border:1px solid rgba(255,255,255,.10);
    color:var(--muted);
  }
  .hint{
    font-size:12px;
    color:var(--muted);
    line-height:1.35;
  }
</style>
</head>
<body>
<div class="wrap">

  <div class="card">
    <div class="hd">
      <div>
        <div class="title">PolyClear Duel — Robust Pass End</div>
        <div class="sub">
          9×9 board with bold 3×3 mini-grids. Rotations allowed (R) + optional flip (F).
          You can overwrite enemy cells but cannot place on your own cells.
          Score from clearing rows/columns/3×3 mini-grids (+9 each). Game ends after two consecutive passes.
        </div>
      </div>
      <div class="row">
        <span class="pill" id="turnPill"><span class="dot p1"></span> P1 turn</span>
        <span class="pill" id="passPill">Pass streak: 0</span>
      </div>
    </div>
    <div class="body">
      <canvas id="board" width="720" height="720"></canvas>
      <div class="hint" style="margin-top:10px;">
        Click to place selected piece • <b>R</b> rotate • <b>F</b> flip • <b>P</b> pass (only if no move exists).
      </div>
    </div>
  </div>

  <div class="card">
    <div class="hd">
      <div>
        <div class="title">Controls</div>
        <div class="sub">Shared 3-piece pool, refills after placement or pass.</div>
      </div>
    </div>
    <div class="body" style="display:flex; flex-direction:column; gap:12px;">
      <div class="row">
        <button id="newBtn">New game</button>
        <button id="rotateBtn">Rotate (R)</button>
        <button id="flipBtn">Flip (F)</button>
        <button id="passBtn" disabled>Pass (P)</button>
      </div>

      <div class="kv">
        <div>Mode</div>
        <div>
          <select id="modeSel">
            <option value="pvp" selected>PvP (local)</option>
            <option value="bot">P1 vs Bot</option>
          </select>
        </div>

        <div>Flip allowed</div>
        <div>
          <select id="flipSel">
            <option value="yes" selected>Yes</option>
            <option value="no">No</option>
          </select>
        </div>

        <div>Pool size</div>
        <div>
          <select id="poolSel">
            <option>3</option>
            <option>4</option>
            <option>5</option>
          </select>
        </div>

        <div>Bag style</div>
        <div><b>Fair bag (one of each)</b></div>
      </div>

      <div class="scoreBox">
        <div class="scoreLine"><span><span class="dot p1"></span> Player 1</span><b id="s1">0</b></div>
        <div class="scoreLine"><span><span class="dot p2"></span> Player 2</span><b id="s2">0</b></div>
      </div>

      <div class="scoreBox">
        <div class="pill" style="margin-bottom:10px;">Piece pool (click to select)</div>
        <div class="pool" id="pool"></div>
      </div>

      <div id="banner" class="banner" style="display:none;"></div>

      <div class="hint">
        Piece set includes: tetrominoes (7), triominoes (2), domino (1×2), plus (5), and pixel (1×1).
        Pixel is rare-ish only because the fair bag contains just one of each per cycle.
      </div>
    </div>
  </div>

</div>

<script>
(() => {
  // ===== Constants =====
  const SIZE = 9;
  const EMPTY = 0, P1 = 1, P2 = 2;

  const COLORS = {
    empty: css('--empty'),
    p1: css('--p1'),
    p2: css('--p2'),
    grid: css('--grid'),
    gridBold: css('--gridBold'),
    panel: css('--panel'),
  };

  // Expanded piece catalog (not just pixel)
  // Coordinates are connected polyominoes; normalization is applied in transforms.
  const PIECES = [
    // Tetrominoes (7)
    { name:'I4', cells:[[0,0],[1,0],[2,0],[3,0]] },
    { name:'O4', cells:[[0,0],[1,0],[0,1],[1,1]] },
    { name:'T4', cells:[[0,0],[1,0],[2,0],[1,1]] },
    { name:'S4', cells:[[1,0],[2,0],[0,1],[1,1]] },
    { name:'Z4', cells:[[0,0],[1,0],[1,1],[2,1]] },
    { name:'J4', cells:[[0,0],[0,1],[1,1],[2,1]] },
    { name:'L4', cells:[[2,0],[0,1],[1,1],[2,1]] },

    // Triominoes (2)
    { name:'I3', cells:[[0,0],[1,0],[2,0]] },
    { name:'L3', cells:[[0,0],[0,1],[1,1]] },

    // Domino
    { name:'I2', cells:[[0,0],[1,0]] },

    // Pentomino-ish (two useful larger shapes)
    { name:'Plus5', cells:[[1,0],[0,1],[1,1],[2,1],[1,2]] }, // "+"

    // Pixel
    { name:'P1', cells:[[0,0]] },
  ];

  // ===== DOM =====
  const boardCv = document.getElementById('board');
  const boardCtx = boardCv.getContext('2d');

  const poolEl = document.getElementById('pool');

  const newBtn = document.getElementById('newBtn');
  const rotateBtn = document.getElementById('rotateBtn');
  const flipBtn = document.getElementById('flipBtn');
  const passBtn = document.getElementById('passBtn');

  const modeSel = document.getElementById('modeSel');
  const flipSel = document.getElementById('flipSel');
  const poolSel = document.getElementById('poolSel');

  const s1El = document.getElementById('s1');
  const s2El = document.getElementById('s2');
  const turnPill = document.getElementById('turnPill');
  const passPill = document.getElementById('passPill');
  const banner = document.getElementById('banner');

  // ===== State =====
  let mode = 'pvp';
  let flipAllowed = true;
  let poolSize = 3;

  let board = null;                 // 2D [y][x] values 0/1/2
  let bag = [];                     // piece indices in PIECES
  let pool = [];                    // array of {pieceIndex}
  let selectedPoolIdx = 0;

  let player = P1;
  let scores = { [P1]:0, [P2]:0 };

  let rot = 0;                      // 0..3
  let flip = false;                 // boolean
  let hover = null;                 // {x,y}
  let passStreak = 0;
  let gameOver = false;

  // ===== Helpers =====
  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
  function shuffle(a){
    for(let i=a.length-1;i>0;i--){
      const j = Math.floor(Math.random()*(i+1));
      [a[i],a[j]] = [a[j],a[i]];
    }
    return a;
  }
  function inBounds(x,y){ return x>=0 && y>=0 && x<SIZE && y<SIZE; }
  function idx(x,y){ return y*SIZE + x; }

  function cloneCells(c){ return c.map(([x,y])=>[x,y]); }
  function normalize(cells){
    const minX = Math.min(...cells.map(c=>c[0]));
    const minY = Math.min(...cells.map(c=>c[1]));
    return cells.map(([x,y])=>[x-minX,y-minY]);
  }
  function rotate90(cells){
    const maxX = Math.max(...cells.map(c=>c[0]));
    return normalize(cells.map(([x,y])=>[y, maxX - x]));
  }
  function transformCells(baseCells, r, f){
    let cells = normalize(cloneCells(baseCells));
    if (f){
      const maxX = Math.max(...cells.map(c=>c[0]));
      cells = cells.map(([x,y])=>[maxX-x, y]);
      cells = normalize(cells);
    }
    for(let i=0;i<r;i++) cells = rotate90(cells);
    return normalize(cells);
  }

  function currentPiece(){
    const pi = pool[selectedPoolIdx]?.pieceIndex;
    if (pi === undefined) return null;
    return PIECES[pi];
  }

  function currentCells(){
    const p = currentPiece();
    if (!p) return null;
    const f = flipAllowed ? flip : false;
    return transformCells(p.cells, rot, f);
  }

  function refillBagIfNeeded(){
    if (bag.length > 0) return;
    // Fair bag: one of each piece per cycle
    bag = shuffle([...PIECES.keys()]);
  }

  function drawFromBag(){
    refillBagIfNeeded();
    return bag.pop();
  }

  function refillPoolToSize(){
    while(pool.length < poolSize){
      pool.push({ pieceIndex: drawFromBag() });
    }
  }

  function discardAndRefillPool(){
    pool = [];
    refillPoolToSize();
    selectedPoolIdx = 0;
    rot = 0;
    flip = false;
  }

  // ===== Rules =====
  function legalPlacementForCells(anchorX, anchorY, cells, p){
    for(const [dx,dy] of cells){
      const x = anchorX + dx, y = anchorY + dy;
      if (!inBounds(x,y)) return false;
      if (board[y][x] === p) return false; // cannot place on own
    }
    return true; // can overwrite enemy/empty
  }

  function applyPlacement(anchorX, anchorY, cells, p){
    for(const [dx,dy] of cells){
      const x = anchorX + dx, y = anchorY + dy;
      board[y][x] = p;
    }
  }

  function completedStructures(p){
    // returns {clearSet:Set<idx>, points:number}
    const clearSet = new Set();
    let points = 0;

    // rows
    for(let y=0;y<SIZE;y++){
      let ok = true;
      for(let x=0;x<SIZE;x++){
        if (board[y][x] !== p){ ok=false; break; }
      }
      if (ok){
        points += 9;
        for(let x=0;x<SIZE;x++) clearSet.add(idx(x,y));
      }
    }

    // cols
    for(let x=0;x<SIZE;x++){
      let ok = true;
      for(let y=0;y<SIZE;y++){
        if (board[y][x] !== p){ ok=false; break; }
      }
      if (ok){
        points += 9;
        for(let y=0;y<SIZE;y++) clearSet.add(idx(x,y));
      }
    }

    // 3×3 mini-grids (delineated)
    for(let gy=0; gy<3; gy++){
      for(let gx=0; gx<3; gx++){
        let ok = true;
        for(let y=0;y<3;y++){
          for(let x=0;x<3;x++){
            if (board[gy*3+y][gx*3+x] !== p){ ok=false; break; }
          }
          if (!ok) break;
        }
        if (ok){
          points += 9;
          for(let y=0;y<3;y++){
            for(let x=0;x<3;x++){
              clearSet.add(idx(gx*3+x, gy*3+y));
            }
          }
        }
      }
    }

    return { clearSet, points };
  }

  function clearBySet(clearSet){
    clearSet.forEach(k=>{
      const x = k % SIZE;
      const y = Math.floor(k / SIZE);
      board[y][x] = EMPTY;
    });
  }

  function hasAnyMoveForPlayer(p){
    // any piece in pool, any rotation, (optional) flip, any anchor
    for(let i=0;i<pool.length;i++){
      const piece = PIECES[pool[i].pieceIndex];
      for(let f=0; f<(flipAllowed?2:1); f++){
        for(let r=0;r<4;r++){
          const cells = transformCells(piece.cells, r, !!f);
          for(let y=0;y<SIZE;y++){
            for(let x=0;x<SIZE;x++){
              if (legalPlacementForCells(x,y,cells,p)) return true;
            }
          }
        }
      }
    }
    return false;
  }

  function updatePassButton(){
    if (gameOver) { passBtn.disabled = true; return; }
    const canMove = hasAnyMoveForPlayer(player);
    passBtn.disabled = canMove; // only allow manual pass if truly stuck
  }

  function doPass(){
    if (gameOver) return;
    if (hasAnyMoveForPlayer(player)) return; // only pass when stuck

    passStreak += 1;
    // Refresh pool to avoid being locked by an unlucky pool
    discardAndRefillPool();

    if (passStreak >= 2){
      endGame();
      return;
    }

    // switch player
    player = (player===P1) ? P2 : P1;

    updateAll();

    if (mode === 'bot' && player === P2){
      setTimeout(botTurn, 120);
    }
  }

  function afterSuccessfulMove(){
    passStreak = 0;
  }

  // ===== Game Flow =====
  function endGame(){
    gameOver = true;
    banner.style.display = 'block';
    const a = scores[P1], b = scores[P2];
    if (a > b){
      banner.className = 'banner p1';
      banner.textContent = `Game over (two consecutive passes). Player 1 wins (${a} vs ${b}).`;
    } else if (b > a){
      banner.className = 'banner p2';
      banner.textContent = `Game over (two consecutive passes). Player 2 wins (${b} vs ${a}).`;
    } else {
      banner.className = 'banner tie';
      banner.textContent = `Game over (two consecutive passes). Tie (${a} vs ${b}).`;
    }
    updatePassButton();
    drawBoard();
  }

  function newGame(){
    mode = modeSel.value;
    flipAllowed = (flipSel.value === 'yes');
    poolSize = parseInt(poolSel.value, 10);

    board = Array.from({length:SIZE}, ()=>Array(SIZE).fill(EMPTY));
    bag = [];
    pool = [];
    selectedPoolIdx = 0;

    player = P1;
    scores = { [P1]:0, [P2]:0 };
    rot = 0;
    flip = false;
    hover = null;

    passStreak = 0;
    gameOver = false;

    banner.style.display = 'none';

    discardAndRefillPool();
    updateAll();

    if (mode === 'bot' && player === P2){
      setTimeout(botTurn, 120);
    }
  }

  function placeAt(anchorX, anchorY){
    if (gameOver) return;
    if (mode === 'bot' && player === P2) return;

    const piece = currentPiece();
    if (!piece) return;

    const cells = currentCells();
    if (!cells) return;

    if (!legalPlacementForCells(anchorX, anchorY, cells, player)) return;

    // Place
    applyPlacement(anchorX, anchorY, cells, player);

    // Score + clear
    const { clearSet, points } = completedStructures(player);
    if (points > 0){
      scores[player] += points;
      clearBySet(clearSet);
    }

    afterSuccessfulMove();

    // Remove used pool piece and refill
    pool.splice(selectedPoolIdx, 1);
    refillPoolToSize();
    selectedPoolIdx = Math.min(selectedPoolIdx, pool.length-1);
    rot = 0;
    flip = false;

    // Switch player
    player = (player===P1) ? P2 : P1;

    updateAll();

    // If current player stuck, enable pass (or auto-pass for bot)
    if (!gameOver && !hasAnyMoveForPlayer(player)){
      updatePassButton();
      if (mode === 'bot' && player === P2){
        // bot auto-passes if stuck
        setTimeout(doPass, 120);
      }
    } else {
      passStreak = 0; // already reset on move, keep safe
      if (mode === 'bot' && player === P2){
        setTimeout(botTurn, 120);
      }
    }
  }

  // ===== Bot =====
  function botTurn(){
    if (gameOver) return;
    if (player !== P2) return;
    if (!hasAnyMoveForPlayer(P2)){
      doPass();
      return;
    }

    // Evaluate all moves from pool with transforms; pick best.
    let best = null;

    for(let i=0;i<pool.length;i++){
      const piece = PIECES[pool[i].pieceIndex];
      for(let f=0; f<(flipAllowed?2:1); f++){
        for(let r=0;r<4;r++){
          const cells = transformCells(piece.cells, r, !!f);

          // quick bounds for scan: (still brute force; board is small)
          for(let y=0;y<SIZE;y++){
            for(let x=0;x<SIZE;x++){
              if (!legalPlacementForCells(x,y,cells,P2)) continue;

              // simulate
              const snapshot = board.map(row=>row.slice());

              // count overwritten enemy cells as a tie-breaker
              let overwrittenEnemy = 0;
              for(const [dx,dy] of cells){
                const xx = x+dx, yy = y+dy;
                if (snapshot[yy][xx] === P1) overwrittenEnemy++;
                snapshot[yy][xx] = P2;
              }

              // compute clears/points on simulated board
              // temporarily swap board pointer for evaluation
              const oldBoard = board;
              board = snapshot;
              const { points } = completedStructures(P2);
              board = oldBoard;

              // heuristic: prioritize points heavily, then aggression a bit
              const score = points*100 + overwrittenEnemy*3;

              if (!best || score > best.score){
                best = { score, poolIdx:i, r, f:!!f, x, y };
              }
            }
          }
        }
      }
    }

    if (!best){
      doPass();
      return;
    }

    // Apply chosen settings and place
    selectedPoolIdx = best.poolIdx;
    rot = best.r;
    flip = best.f;

    updateAll();
    setTimeout(()=>placeAt(best.x, best.y), 120);
  }

  // ===== Rendering =====
  function resizeCanvases(){
    boardCv.width = 720; boardCv.height = 720;
  }

  function drawBoard(){
    const W = boardCv.width, H = boardCv.height;
    boardCtx.clearRect(0,0,W,H);
    boardCtx.fillStyle = COLORS.panel;
    boardCtx.fillRect(0,0,W,H);

    const cell = Math.floor(Math.min(W,H) / SIZE);
    const ox = Math.floor((W - cell*SIZE)/2);
    const oy = Math.floor((H - cell*SIZE)/2);

    // fill
    for(let y=0;y<SIZE;y++){
      for(let x=0;x<SIZE;x++){
        const v = board[y][x];
        boardCtx.fillStyle = (v===P1) ? COLORS.p1 : (v===P2) ? COLORS.p2 : COLORS.empty;
        boardCtx.fillRect(ox + x*cell, oy + y*cell, cell, cell);
      }
    }

    // light grid
    boardCtx.strokeStyle = COLORS.grid;
    boardCtx.lineWidth = 1;
    for(let i=0;i<=SIZE;i++){
      const x = ox + i*cell + 0.5;
      const y = oy + i*cell + 0.5;

      boardCtx.beginPath();
      boardCtx.moveTo(x, oy);
      boardCtx.lineTo(x, oy + SIZE*cell);
      boardCtx.stroke();

      boardCtx.beginPath();
      boardCtx.moveTo(ox, y);
      boardCtx.lineTo(ox + SIZE*cell, y);
      boardCtx.stroke();
    }

    // bold 3×3 delineation
    boardCtx.strokeStyle = COLORS.gridBold;
    boardCtx.lineWidth = 3;
    for(let i=0;i<=SIZE;i+=3){
      const x = ox + i*cell + 0.5;
      const y = oy + i*cell + 0.5;

      boardCtx.beginPath();
      boardCtx.moveTo(x, oy);
      boardCtx.lineTo(x, oy + SIZE*cell);
      boardCtx.stroke();

      boardCtx.beginPath();
      boardCtx.moveTo(ox, y);
      boardCtx.lineTo(ox + SIZE*cell, y);
      boardCtx.stroke();
    }

    // hover preview
    if (!gameOver && hover){
      const cells = currentCells();
      if (cells){
        const ok = legalPlacementForCells(hover.x, hover.y, cells, player);
        const ghost = (player===P1) ? 'rgba(255,90,122,.35)' : 'rgba(77,211,255,.35)';
        const bad = 'rgba(255,255,255,.10)';
        boardCtx.fillStyle = ok ? ghost : bad;
        for(const [dx,dy] of cells){
          const x = hover.x + dx, y = hover.y + dy;
          if (!inBounds(x,y)) continue;
          boardCtx.fillRect(ox + x*cell, oy + y*cell, cell, cell);
        }
      }
    }

    // border
    boardCtx.strokeStyle = 'rgba(255,255,255,.18)';
    boardCtx.lineWidth = 2;
    boardCtx.strokeRect(ox + 1, oy + 1, SIZE*cell - 2, SIZE*cell - 2);
  }

  function drawPool(){
    poolEl.innerHTML = '';
    const cols = poolSize;
    poolEl.style.gridTemplateColumns = `repeat(${cols}, 1fr)`;

    for(let i=0;i<pool.length;i++){
      const wrap = document.createElement('div');
      wrap.className = 'poolItem' + (i===selectedPoolIdx ? ' selected' : '');
      wrap.addEventListener('click', () => {
        if (gameOver) return;
        if (mode === 'bot' && player === P2) return;
        selectedPoolIdx = i;
        rot = 0;
        flip = false;
        updateAll();
      });

      const tag = document.createElement('div');
      tag.className = 'tag';
      tag.textContent = PIECES[pool[i].pieceIndex].name;
      wrap.appendChild(tag);

      const cv = document.createElement('canvas');
      cv.width = 220;
      cv.height = 150;
      wrap.appendChild(cv);

      const ctx = cv.getContext('2d');
      ctx.fillStyle = 'rgba(0,0,0,.12)';
      ctx.fillRect(0,0,cv.width,cv.height);

      const piece = PIECES[pool[i].pieceIndex];
      const cells = transformCells(piece.cells, 0, false);
      const maxX = Math.max(...cells.map(c=>c[0]));
      const maxY = Math.max(...cells.map(c=>c[1]));
      const w = maxX+1, h = maxY+1;

      const pad = 14;
      const cell = Math.floor(Math.min((cv.width-2*pad)/w, (cv.height-2*pad)/h));
      const ox = Math.floor((cv.width - cell*w)/2);
      const oy = Math.floor((cv.height - cell*h)/2);

      ctx.fillStyle = (player===P1) ? COLORS.p1 : COLORS.p2;
      for(const [x,y] of cells){
        ctx.fillRect(ox + x*cell, oy + y*cell, cell-2, cell-2);
      }
      // note: pool previews show canonical orientation; rotation applies at placement-time
      poolEl.appendChild(wrap);
    }
  }

  function updateHUD(){
    s1El.textContent = scores[P1];
    s2El.textContent = scores[P2];

    turnPill.innerHTML = `<span class="dot ${player===P1?'p1':'p2'}"></span> ${player===P1?'P1':'P2'} turn`;
    passPill.textContent = `Pass streak: ${passStreak}`;

    updatePassButton();
  }

  function updateAll(){
    drawBoard();
    drawPool();
    updateHUD();
  }

  // ===== Input =====
  function boardToCell(evt){
    const rect = boardCv.getBoundingClientRect();
    const mx = evt.clientX - rect.left;
    const my = evt.clientY - rect.top;

    const sx = boardCv.width / rect.width;
    const sy = boardCv.height / rect.height;

    const W = boardCv.width, H = boardCv.height;
    const cell = Math.floor(Math.min(W,H) / SIZE);
    const ox = Math.floor((W - cell*SIZE)/2);
    const oy = Math.floor((H - cell*SIZE)/2);

    const x = Math.floor((mx*sx - ox)/cell);
    const y = Math.floor((my*sy - oy)/cell);
    return {x,y};
  }

  boardCv.addEventListener('mousemove', (e) => {
    if (gameOver) return;
    const {x,y} = boardToCell(e);
    hover = {x,y};
    drawBoard();
  });

  boardCv.addEventListener('mouseleave', () => {
    hover = null;
    drawBoard();
  });

  boardCv.addEventListener('click', (e) => {
    if (gameOver) return;
    const {x,y} = boardToCell(e);
    placeAt(x,y);
  });

  rotateBtn.addEventListener('click', () => {
    if (gameOver) return;
    if (mode === 'bot' && player === P2) return;
    rot = (rot + 1) % 4;
    drawBoard();
  });

  flipBtn.addEventListener('click', () => {
    if (gameOver) return;
    if (!flipAllowed) return;
    if (mode === 'bot' && player === P2) return;
    flip = !flip;
    drawBoard();
  });

  passBtn.addEventListener('click', () => {
    if (mode === 'bot' && player === P2) return;
    doPass();
  });

  window.addEventListener('keydown', (e) => {
    if (gameOver) return;
    if (mode === 'bot' && player === P2) return;

    if (e.key === 'r' || e.key === 'R'){
      rot = (rot + 1) % 4;
      drawBoard();
    }
    if ((e.key === 'f' || e.key === 'F') && flipAllowed){
      flip = !flip;
      drawBoard();
    }
    if (e.key === 'p' || e.key === 'P'){
      doPass();
    }
  });

  // ===== Controls =====
  newBtn.addEventListener('click', newGame);
  modeSel.addEventListener('change', () => { mode = modeSel.value; });
  flipSel.addEventListener('change', () => { flipAllowed = (flipSel.value === 'yes'); flip = false; updateAll(); });
  poolSel.addEventListener('change', () => { poolSize = parseInt(poolSel.value,10); discardAndRefillPool(); updateAll(); });

  // ===== Boot =====
  resizeCanvases();
  newGame();

  // ===== Small utility =====
  function css(v){ return getComputedStyle(document.documentElement).getPropertyValue(v).trim(); }
})();
</script>
</body>
</html>