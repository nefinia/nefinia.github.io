<!DOCTYPE html>
<html lang="en">
<head>
<!-- Global site tag (gtag.js) - Google Analytics -->
<script async src="https://www.googletagmanager.com/gtag/js?id=G-20EEFX7Q6N"></script>
<script>
  window.dataLayer = window.dataLayer || [];
  function gtag(){dataLayer.push(arguments);}
  gtag('js', new Date());
  gtag('config', 'G-20EEFX7Q6N');
</script>

<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Tint Tactics</title>

<style>
  :root{
    --n: 8;
    --cell: 56px;
    --gap: 2px;

    /* Board (more chess-like contrast, neutral frame) */
    --sq-light: #f3f4f6;
    --sq-dark:  #b7c0cc;
    --grid-bg:  #1f232b;

    /* Territory overlay (subtle) */
    --own-blue: rgba(11, 61, 145, 0.4);
    --own-red:  rgba(127, 16, 37, 0.4);

    /* Pieces (darker tones) */
    --blue: #0b3d91;
    --red:  #7f1025;

    /* UI */
    --frame: #1f232b;
    --panel: #ffffff;
    --panelBorder: rgba(0,0,0,0.12);
    --shadow: 0 10px 30px rgba(0,0,0,0.10);
    --radius: 14px;

    /* Turn accent */
    --turn-blue: rgba(11, 61, 145, 0.18);
    --turn-red:  rgba(127, 16, 37, 0.18);

    /* Motion */
    --t-move: 140ms;
    --t-claim: 180ms;

    /* Outlines (selection + hints) */
    --olw: 3px; /* outline width */
    --sel-ol: rgba(0,0,0,0.55);
    /* darker borders for allowed cells when a piece is selected */
    --hint-ol: rgba(0,0,0,0.34);
    --hintcap-ol: rgba(0,0,0,0.38);

    --bot-from-ol: rgba(127,16,37,0.62);
    --bot-to-ol: rgba(127,16,37,0.30);
  }

  body{
    margin:0;
    padding:14px 10px 28px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background:#fafafa;
    color:#111;
    text-align:center;
  }
  h2{
    margin:6px 0 10px;
    letter-spacing:0.2px;
  }

  /* ===== Top rules card ===== */
  #rules{
    width:min(100vw - 20px, 980px);
    margin:0 auto 10px;
    text-align:left;
    background:var(--panel);
    border:1px solid var(--panelBorder);
    border-radius: var(--radius);
    padding:10px 12px;
    line-height:1.35;
    font-size:13px;
    color:#222;
    box-shadow: 0 6px 20px rgba(0,0,0,0.06);
  }
  #rules b{ font-weight:800; }
  #rules ul{ margin:6px 0 0 18px; padding:0; }
  #rules li{ margin:3px 0; }

  /* ===== HUD ===== */
  #hud{
    display:flex;
    flex-wrap:wrap;
    justify-content:center;
    gap:10px 12px;
    align-items:center;
    margin-bottom:10px;
  }
  .pill{
    display:flex;
    gap:8px;
    align-items:center;
    padding:8px 10px;
    border:1px solid var(--panelBorder);
    border-radius:999px;
    background:var(--panel);
    white-space:nowrap;
    box-shadow: 0 2px 10px rgba(0,0,0,0.04);
  }
  .label{ color:#444; font-size:13px; }
  .value{ font-weight:800; font-size:15px; }
  .p1{ color:var(--blue); }
  .p2{ color:var(--red); }

  button, select{
    font-size:14px;
    padding:7px 10px;
    border-radius:10px;
    border:1px solid var(--panelBorder);
    background:#fff;
    box-shadow: 0 1px 0 rgba(0,0,0,0.04);
  }
  button{
    cursor:pointer;
    font-weight:700;
  }
  button:hover{ filter:brightness(0.98); }

  #wrap{ width:min(100vw - 20px, 560px); margin:0 auto; }

  /* ===== Board frame + turn accent ===== */
  #board{
    display:inline-block;
    border:2px solid var(--frame);
    background:var(--grid-bg);
    padding:3px;
    box-sizing:content-box;
    border-radius: 12px;
    box-shadow: var(--shadow);
    transition: box-shadow 180ms ease, border-color 180ms ease;
  }
  #board.turnBlue{
    box-shadow: 0 0 0 4px var(--turn-blue), var(--shadow);
  }
  #board.turnRed{
    box-shadow: 0 0 0 4px var(--turn-red), var(--shadow);
  }

  #grid{
    display:grid;
    grid-template-columns: repeat(var(--n), var(--cell));
    grid-template-rows: repeat(var(--n), var(--cell));
    gap: var(--gap);
    background:var(--grid-bg);
    border-radius: 10px;
    overflow:hidden;
  }

  /* ===== Cells ===== */
  .cell{
    position:relative;
    width:var(--cell);
    height:var(--cell);
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
    cursor:pointer;
    font-size: calc(var(--cell) * 0.56);
    line-height:1;
    background: var(--sq-light);
    font-family: "Apple Color Emoji","Segoe UI Symbol", system-ui, sans-serif;
    transition: transform 90ms ease;
    border-radius: 8px;
    overflow: hidden;
  }
  .cell.parity1{ background: var(--sq-dark); }
  .cell:active{ transform: scale(0.99); }

  /* Territory mark: full-cell translucent overlay */
  .cell::after{
    content:"";
    position:absolute;
    inset: 0;
    pointer-events:none;
    opacity: 0;
    transition: opacity var(--t-claim) ease;
  }
  .cell.c1::after{ background: var(--own-blue); opacity: 1; }
  .cell.c2::after{ background: var(--own-red);  opacity: 1; }

  /* Selection + move hints */
  .sel{
    outline: var(--olw) solid var(--sel-ol);
    outline-offset: calc(-1 * var(--olw));
  }
  .hint{
    outline: var(--olw) solid var(--hint-ol);
    outline-offset: calc(-1 * var(--olw));
  }
  .hintCapture{
    outline: var(--olw) solid var(--hintcap-ol);
    outline-offset: calc(-1 * var(--olw));
    box-shadow: inset 0 0 0 999px rgba(0,0,0,0.06);
  }

  /* Bot animation cues */
  .botFrom{
    outline: var(--olw) solid var(--bot-from-ol);
    outline-offset: calc(-1 * var(--olw));
  }
  .botTo{
    outline: var(--olw) solid var(--bot-to-ol);
    outline-offset: calc(-1 * var(--olw));
    box-shadow: inset 0 0 0 999px rgba(127,16,37,0.06);
  }

  /* Pieces */
  .piece{
    font-weight:900;
    text-shadow:
      0 1px 0 rgba(0,0,0,0.10),
      0 6px 18px rgba(0,0,0,0.08);
    transform: translateZ(0);
  }
  .pieceBlue{ color: var(--blue); }
  .pieceRed { color: var(--red); }

  /* subtle "your turn" glow on your pieces (only in bot mode) */
  .youTurnBlue .pieceBlue{ filter: drop-shadow(0 0 6px rgba(11,61,145,0.18)); }
  .youTurnRed  .pieceRed { filter: drop-shadow(0 0 6px rgba(127,16,37,0.18)); }

  .disabled{
    opacity:0.72;
    pointer-events:none;
    filter: grayscale(0.08);
  }

  .msg{
    margin-top:10px;
    font-size:13px;
    color:#444;
  }
  .legend{
    margin-top:8px;
    display:flex;
    justify-content:center;
    flex-wrap:wrap;
    gap:10px 14px;
    font-size:13px;
    color:#333;
  }
  .dot{
    display:inline-block;
    width:12px; height:12px;
    border-radius:999px;
    vertical-align:middle;
    margin-right:6px;
    border:1px solid rgba(0,0,0,0.18);
    background: rgba(0,0,0,0.05);
  }
  .dot1{ box-shadow: inset 0 0 0 4px rgba(11,61,145,0.35); background:transparent; }
  .dot2{ box-shadow: inset 0 0 0 4px rgba(127,16,37,0.35);  background:transparent; }

  .smallNote{ font-size:12px; color:#555; margin-top:6px; }
  option{ font-family: "Apple Color Emoji", "Segoe UI Symbol", system-ui, sans-serif; }

  /* ===== Game Over modal ===== */
  #overlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.48);
    z-index: 9999;
    padding: 18px;
  }
  #overlay.show{ display:flex; }

  #modal{
    width:min(92vw, 520px);
    border-radius:16px;
    background:#fff;
    border:1px solid rgba(0,0,0,0.14);
    box-shadow: 0 18px 60px rgba(0,0,0,0.28);
    padding: 16px 16px 14px;
    text-align:left;
  }
  #modal h3{
    margin:0 0 8px;
    font-size: 18px;
  }
  #winnerBanner{
    margin: 8px 0 12px;
    padding: 10px 12px;
    border-radius: 12px;
    font-weight: 900;
    font-size: 18px;
    letter-spacing: 0.3px;
    border: 1px solid rgba(0,0,0,0.10);
  }
  #winnerBanner.blue{
    color: var(--blue);
    background: rgba(11,61,145,0.10);
  }
  #winnerBanner.red{
    color: var(--red);
    background: rgba(127,16,37,0.10);
  }
  #winnerBanner.draw{
    color: #222;
    background: rgba(0,0,0,0.06);
  }
  #modal .row{
    display:flex;
    justify-content:space-between;
    margin: 6px 0;
    font-size:14px;
  }
  #modal .row b{ font-weight:800; }
  #modal .actions{
    margin-top: 12px;
    display:flex;
    gap: 10px;
    justify-content:flex-end;
  }

  /* Better “game over” feel: dim board under overlay */
  body.gameOver #board{
    filter: grayscale(0.10) brightness(0.96);
  }

  /* Mobile: reduce outline thickness + slightly tighter rounding */
  @media (max-width: 520px){
    :root{ --olw: 2px; }
    #board{ padding:2px; border-radius: 10px; }
    #grid{ border-radius: 8px; }
    .cell{ border-radius: 7px; }
  }

    .back-link{
      position: fixed;
      bottom: 16px;
      top: auto;
      left: 16px;
      z-index: 1000;
      display: inline-flex;
      align-items: center;
      gap: 8px;
      padding: 8px 12px;
      border-radius: 999px;
      background: rgba(9, 14, 30, 0.72);
      border: 1px solid rgba(122,162,255,.45);
      color: #eef2ff;
      text-decoration: none;
      font-size: 12px;
      font-weight: 700;
      letter-spacing: .02em;
      box-shadow: 0 12px 30px rgba(0,0,0,.35);
      backdrop-filter: blur(8px);
      transition: transform .12s ease, border-color .12s ease, background .12s ease;
    }
    .back-link:hover{
      transform: translateY(-1px);
      border-color: rgba(122,162,255,.8);
      background: rgba(12, 18, 36, 0.9);
    }
  </style>
</head>

<body>

  <a class="back-link" href="index.html" aria-label="Back to games">← Back to games</a>
<h2>Tint Tactics</h2>

<div id="rules">
  <b>Goal:</b> Win by the selected win condition.
  <ul>
    <li>Move like chess. No check rules.</li>
    <li>Your <b>destination square</b> becomes your color (overwrites the opponent’s mark).</li>
    <li>If you capture an enemy piece, it <b>respawns as the same type</b> on a random empty square. Respawning does <b>not</b> claim the square.</li>
    <li><b>Fair respawn:</b> prefers squares where the respawned piece has <b>no immediate captures</b> and is <b>not attacked</b>, if possible.</li>
    <li><b>Fair start:</b> initial positions are generated so <b>no immediate captures</b> are possible for either side.</li>
    <li><b>Vs Bot:</b> your color and the starting side are randomized (shown below).</li>
  </ul>
</div>

<div id="hud">
  <div class="pill">
    <span class="label">Mode:</span>
    <select id="modeSel">
      <option value="bot" selected>Vs Bot</option>
      <option value="2p">2 Players</option>
    </select>
  </div>

  <div class="pill" id="whoPill">
    <span class="label">You:</span>
    <span class="value" id="youColorText"></span>
    <span class="label" style="margin-left:8px;">Bot:</span>
    <span class="value" id="botColorText"></span>
  </div>

  <div class="pill">
    <span class="label">Win:</span>
    <select id="winModeSel">
      <option value="turns" selected>Most territory after turns</option>
      <option value="line">Complete a row or column</option>
    </select>
  </div>

  <div class="pill">
    <span class="label">Piece set:</span>
    <select id="pieceSetSel"></select>
  </div>

  <div class="pill">
    <span class="label">Turn:</span>
    <span class="value" id="turnText"></span>
  </div>

  <div class="pill" id="turnsLeftPill">
    <span class="label">Turns left:</span>
    <span class="value" id="turnsLeft">20</span>
  </div>

  <div class="pill">
    <span class="label"><span class="p1">Blue</span> territory:</span>
    <span class="value p1" id="score1">0</span>
  </div>

  <div class="pill">
    <span class="label"><span class="p2">Red</span> territory:</span>
    <span class="value p2" id="score2">0</span>
  </div>

  <div class="pill">
    <span class="label">Board:</span>
    <select id="boardSize">
      <option value="6">6×6</option>
      <option value="7">7×7</option>
      <option value="8" selected>8×8</option>
      <option value="9">9×9</option>
    </select>
  </div>

  <div class="pill" id="turnLimitPill">
    <span class="label">Turns/side:</span>
    <select id="turnLimit">
      <option value="10">10</option>
      <option value="15">15</option>
      <option value="20" selected>20</option>
      <option value="25">25</option>
      <option value="30">30</option>
    </select>
  </div>

  <button id="newGameBtn">New Game</button>
</div>

<div id="wrap">
  <div id="board"><div id="grid"></div></div>
  <div class="smallNote" id="setNote"></div>
</div>

<div class="legend">
  <span><span class="dot dot1"></span>Blue-owned squares</span>
  <span><span class="dot dot2"></span>Red-owned squares</span>
</div>

<div class="msg" id="msg">Click a piece, then a highlighted destination.</div>

<!-- Game Over Overlay -->
<div id="overlay" role="dialog" aria-modal="true" aria-label="Game Over">
  <div id="modal">
    <h3>Game Over</h3>
    <div id="winnerBanner" class="draw">DRAW</div>
    <div class="row"><span>Blue territory</span> <b id="finalBlue">0</b></div>
    <div class="row"><span>Red territory</span> <b id="finalRed">0</b></div>
    <div class="row"><span>Win condition</span> <b id="finalWinMode">—</b></div>
    <div class="row"><span>Piece set</span> <b id="finalSet">—</b></div>
    <div class="row"><span>Mode</span> <b id="finalMode">—</b></div>
    <div class="actions">
      <button id="closeOverlayBtn">Close</button>
      <button id="playAgainBtn">Play again</button>
    </div>
  </div>
</div>

<script>
const BLUE = 1;
const RED  = 2;

/* FILLED glyphs (black-piece Unicode), colored via CSS */
const GLYPH = {
  rook:   "♜",
  bishop: "♝",
  knight: "♞",
  queen:  "♛",
  king:   "♚",
  pawn:   "♟"
};

const PIECE_SETS = [
  { id:"mini3",      name:"♜ ♝ ♞",              perSide:["rook","bishop","knight"] },
  { id:"classic6",   name:"♜ ♞ ♞ ♝ ♝ ♚",        perSide:["rook","knight","knight","bishop","bishop","king"] },
  { id:"queen4",     name:"♛ ♜ ♝ ♞",            perSide:["queen","rook","bishop","knight"] },
  { id:"queen5k",    name:"♛ ♜ ♝ ♞ ♚",          perSide:["queen","rook","bishop","knight","king"] },
  { id:"queen6",     name:"♛ ♜ ♞ ♞ ♝ ♚",        perSide:["queen","rook","knight","knight","bishop","king"] },
  { id:"pawnsLite6", name:"♜ ♝ ♞ ♚ ♟ ♟",        perSide:["rook","bishop","knight","king","pawn","pawn"] },
  { id:"pawnsPlus8", name:"♛ ♜ ♝ ♞ ♚ ♟ ♟ ♟",    perSide:["queen","rook","bishop","knight","king","pawn","pawn","pawn"] }
];

const BOT_THINK_MS = 420;
const BOT_SHOW_MS  = 260;

/* === RNG (per game) === */
let RNG_SEED = 0;
function reseedRng(){
  RNG_SEED = (Date.now() ^ ((Math.random()*1e9)|0)) >>> 0;
}
function rand01(){
  RNG_SEED ^= (RNG_SEED << 13); RNG_SEED >>>= 0;
  RNG_SEED ^= (RNG_SEED >>> 17); RNG_SEED >>>= 0;
  RNG_SEED ^= (RNG_SEED << 5);  RNG_SEED >>>= 0;
  return (RNG_SEED >>> 0) / 4294967296;
}
function shuffleInPlace(arr){
  for (let i=arr.length-1; i>0; i--){
    const j = Math.floor(rand01() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
function pickRandom(arr){
  return arr[Math.floor(rand01() * arr.length)];
}

const state = {
  n: 8,
  turnLimit: 20,
  turnsLeft: { [BLUE]: 20, [RED]: 20 },
  current: BLUE,
  selectedId: null,
  gameOver: false,
  busy: false,
  mode: "bot",
  winMode: "turns",
  territory: [],
  pieces: [],
  pieceSetId: "queen5k",
  userColor: BLUE,
  botColor: RED
};

const gridEl = document.getElementById("grid");
const msgEl = document.getElementById("msg");
const turnTextEl = document.getElementById("turnText");
const turnsLeftEl = document.getElementById("turnsLeft");
const score1El = document.getElementById("score1");
const score2El = document.getElementById("score2");
const boardSizeSel = document.getElementById("boardSize");
const turnLimitSel = document.getElementById("turnLimit");
const newGameBtn = document.getElementById("newGameBtn");
const modeSel = document.getElementById("modeSel");
const winModeSel = document.getElementById("winModeSel");
const boardEl = document.getElementById("board");
const pieceSetSel = document.getElementById("pieceSetSel");
const setNote = document.getElementById("setNote");

const whoPill = document.getElementById("whoPill");
const youColorText = document.getElementById("youColorText");
const botColorText = document.getElementById("botColorText");
const turnsLeftPill = document.getElementById("turnsLeftPill");
const turnLimitPill = document.getElementById("turnLimitPill");

const overlayEl = document.getElementById("overlay");
const winnerBannerEl = document.getElementById("winnerBanner");
const finalBlueEl = document.getElementById("finalBlue");
const finalRedEl = document.getElementById("finalRed");
const finalWinModeEl = document.getElementById("finalWinMode");
const finalSetEl = document.getElementById("finalSet");
const finalModeEl = document.getElementById("finalMode");
const closeOverlayBtn = document.getElementById("closeOverlayBtn");
const playAgainBtn = document.getElementById("playAgainBtn");

closeOverlayBtn.addEventListener("click", () => overlayEl.classList.remove("show"));
playAgainBtn.addEventListener("click", () => { overlayEl.classList.remove("show"); newGame(); });

function setCellSize(){
  const wrap = document.getElementById("wrap");
  const w = wrap.getBoundingClientRect().width;
  const n = state.n;
  const usable = Math.floor(w - 14);
  const cell = Math.max(34, Math.min(72, Math.floor((usable - (n-1)*2 - 4) / n)));
  document.documentElement.style.setProperty("--cell", cell + "px");
}
window.addEventListener("resize", setCellSize);

function inBounds(x,y){ return x>=0 && x<state.n && y>=0 && y<state.n; }
function cellId(x,y){ return `c_${x}_${y}`; }
function getPieceAt(x,y){ return state.pieces.find(p => p.x===x && p.y===y) || null; }
function isOccupied(x,y){ return !!getPieceAt(x,y); }

/* UI */
function clearMarks(){
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.getElementById(cellId(x,y));
      el.classList.remove("sel","hint","hintCapture","botFrom","botTo");
    }
  }
}
function cssColorName(owner){
  return owner===BLUE ? `<span class="p1">Blue</span>` : `<span class="p2">Red</span>`;
}
function roleLabels(){
  if (state.mode !== "bot"){
    whoPill.style.display = "none";
    return;
  }
  whoPill.style.display = "flex";
  youColorText.innerHTML = cssColorName(state.userColor);
  botColorText.innerHTML = cssColorName(state.botColor);
}
function setBoardTurnAccent(){
  boardEl.classList.remove("turnBlue","turnRed");
  if (state.current===BLUE) boardEl.classList.add("turnBlue");
  if (state.current===RED)  boardEl.classList.add("turnRed");

  document.body.classList.remove("youTurnBlue","youTurnRed");
  if (state.mode==="bot" && state.current===state.userColor){
    document.body.classList.add(state.userColor===BLUE ? "youTurnBlue" : "youTurnRed");
  }
}
function setTurnUI(){
  turnTextEl.innerHTML = cssColorName(state.current);
  turnsLeftEl.textContent = state.turnsLeft[state.current];

  const usingTurns = (state.winMode === "turns");
  turnsLeftPill.style.display = usingTurns ? "flex" : "none";
  turnLimitPill.style.display = usingTurns ? "flex" : "none";

  setBoardTurnAccent();

  if (state.gameOver) return;

  if (state.mode==="bot"){
    const isBotTurn = (state.current === state.botColor);
    msgEl.textContent = isBotTurn ? "Bot is thinking…" : "Your turn: select a piece, then a highlighted destination.";
  }else{
    msgEl.textContent = "Select a piece, then a highlighted destination.";
  }
}

/* territory */
function initTerritory(){
  state.territory = Array.from({length: state.n}, () => Array(state.n).fill(0));
}
function applyTerritoryClass(el, owner){
  el.classList.remove("c1","c2");
  if (owner===BLUE) el.classList.add("c1");
  else if (owner===RED) el.classList.add("c2");
}
function claimCell(x,y, owner){
  state.territory[y][x] = owner;
  const el = document.getElementById(cellId(x,y));
  if (el) applyTerritoryClass(el, owner);
}
function refreshAllTerritory(){
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.getElementById(cellId(x,y));
      if (!el) continue;
      applyTerritoryClass(el, state.territory[y][x]);
    }
  }
}
function countTerritory(){
  let a=0,b=0;
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      if (state.territory[y][x]===BLUE) a++;
      else if (state.territory[y][x]===RED) b++;
    }
  }
  score1El.textContent = a;
  score2El.textContent = b;
  return {a,b};
}

/* win condition: line */
function hasFullRowOrCol(owner){
  for (let y=0;y<state.n;y++){
    let ok = true;
    for (let x=0;x<state.n;x++){
      if (state.territory[y][x] !== owner){ ok=false; break; }
    }
    if (ok) return true;
  }
  for (let x=0;x<state.n;x++){
    let ok = true;
    for (let y=0;y<state.n;y++){
      if (state.territory[y][x] !== owner){ ok=false; break; }
    }
    if (ok) return true;
  }
  return false;
}
function maybeEndByLineWin(lastMover){
  if (state.winMode !== "line") return false;
  if (hasFullRowOrCol(lastMover)){
    finalizeGameImmediate(lastMover);
    return true;
  }
  return false;
}

/* board */
function buildBoard(){
  document.documentElement.style.setProperty("--n", state.n);
  gridEl.innerHTML = "";
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.createElement("div");
      el.id = cellId(x,y);
      el.className = "cell" + (((x+y)%2) ? " parity1" : "");
      el.addEventListener("click", () => onCellClick(x,y), {passive:true});
      gridEl.appendChild(el);
    }
  }
  setCellSize();
}

function renderPieces(){
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.getElementById(cellId(x,y));
      el.textContent = "";
      el.classList.remove("piece","pieceBlue","pieceRed");
    }
  }
  for (const p of state.pieces){
    const el = document.getElementById(cellId(p.x,p.y));
    if (!el) continue;
    el.textContent = GLYPH[p.type] || "?";
    el.classList.add("piece", p.owner===BLUE ? "pieceBlue" : "pieceRed");
  }
}

/* moves (legal captures depend on occupancy) */
function rayMoves(p, dirs){
  const moves = [];
  for (const [dx,dy] of dirs){
    let x=p.x+dx, y=p.y+dy;
    while (inBounds(x,y)){
      const occ=getPieceAt(x,y);
      if (!occ) moves.push({x,y,capture:false});
      else { if (occ.owner!==p.owner) moves.push({x,y,capture:true}); break; }
      x+=dx; y+=dy;
    }
  }
  return moves;
}
function knightMoves(p){
  const deltas=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  const moves=[];
  for (const [dx,dy] of deltas){
    const x=p.x+dx, y=p.y+dy;
    if (!inBounds(x,y)) continue;
    const occ=getPieceAt(x,y);
    if (!occ) moves.push({x,y,capture:false});
    else if (occ.owner!==p.owner) moves.push({x,y,capture:true});
  }
  return moves;
}
function kingMoves(p){
  const moves=[];
  for (let dy=-1; dy<=1; dy++){
    for (let dx=-1; dx<=1; dx++){
      if (dx===0 && dy===0) continue;
      const x=p.x+dx, y=p.y+dy;
      if (!inBounds(x,y)) continue;
      const occ=getPieceAt(x,y);
      if (!occ) moves.push({x,y,capture:false});
      else if (occ.owner!==p.owner) moves.push({x,y,capture:true});
    }
  }
  return moves;
}
function pawnMoves(p){
  const dir = (p.owner===BLUE) ? -1 : 1;
  const moves=[];
  const fwdY = p.y + dir;

  if (inBounds(p.x, fwdY) && !isOccupied(p.x, fwdY)){
    moves.push({x:p.x, y:fwdY, capture:false});
  }
  for (const dx of [-1, 1]){
    const cx = p.x + dx, cy = p.y + dir;
    if (!inBounds(cx,cy)) continue;
    const occ = getPieceAt(cx,cy);
    if (occ && occ.owner !== p.owner){
      moves.push({x:cx, y:cy, capture:true});
    }
  }
  return moves;
}
function legalMovesFor(p){
  if (p.type==="rook")   return rayMoves(p, [[1,0],[-1,0],[0,1],[0,-1]]);
  if (p.type==="bishop") return rayMoves(p, [[1,1],[1,-1],[-1,1],[-1,-1]]);
  if (p.type==="queen")  return rayMoves(p, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]);
  if (p.type==="knight") return knightMoves(p);
  if (p.type==="king")   return kingMoves(p);
  if (p.type==="pawn")   return pawnMoves(p);
  return [];
}

/* attack detection (critical for fair respawn) */
function attacksSquare(piece, tx, ty){
  if (piece.x===tx && piece.y===ty) return false;

  const dx = tx - piece.x;
  const dy = ty - piece.y;

  if (piece.type==="knight"){
    const ax = Math.abs(dx), ay = Math.abs(dy);
    return (ax===2 && ay===1) || (ax===1 && ay===2);
  }
  if (piece.type==="king"){
    return Math.max(Math.abs(dx), Math.abs(dy)) === 1;
  }
  if (piece.type==="pawn"){
    const dir = (piece.owner===BLUE) ? -1 : 1;
    return (dy === dir) && (Math.abs(dx) === 1);
  }

  function rayAttacks(stepX, stepY){
    let x = piece.x + stepX;
    let y = piece.y + stepY;
    while (inBounds(x,y)){
      if (x===tx && y===ty) return true;
      if (isOccupied(x,y)) return false;
      x += stepX; y += stepY;
    }
    return false;
  }

  if (piece.type==="rook"){
    if (dx===0 && dy!==0) return rayAttacks(0, Math.sign(dy));
    if (dy===0 && dx!==0) return rayAttacks(Math.sign(dx), 0);
    return false;
  }
  if (piece.type==="bishop"){
    if (Math.abs(dx)===Math.abs(dy) && dx!==0) return rayAttacks(Math.sign(dx), Math.sign(dy));
    return false;
  }
  if (piece.type==="queen"){
    if (dx===0 && dy!==0) return rayAttacks(0, Math.sign(dy));
    if (dy===0 && dx!==0) return rayAttacks(Math.sign(dx), 0);
    if (Math.abs(dx)===Math.abs(dy) && dx!==0) return rayAttacks(Math.sign(dx), Math.sign(dy));
    return false;
  }
  return false;
}
function squareAttackedByOwner(owner, x, y){
  for (const p of state.pieces){
    if (p.owner !== owner) continue;
    if (attacksSquare(p, x, y)) return true;
  }
  return false;
}

/* strict fair start */
function anyImmediateCaptureExists(){
  for (const p of state.pieces){
    for (const m of legalMovesFor(p)){
      if (m.capture) return true;
    }
  }
  return false;
}
function currentPieceSet(){
  return PIECE_SETS.find(s => s.id===state.pieceSetId) || PIECE_SETS[0];
}
function placePiecesNoClaim(){
  state.pieces = [];
  const set = currentPieceSet();
  let idx = 0;

  const squares = [];
  for (let y=0;y<state.n;y++) for (let x=0;x<state.n;x++) squares.push({x,y});
  shuffleInPlace(squares);

  let ptr = 0;
  function nextEmpty(){
    while (ptr < squares.length){
      const s = squares[ptr++];
      if (!isOccupied(s.x,s.y)) return s;
    }
    return null;
  }

  for (const owner of [BLUE, RED]){
    for (const type of set.perSide){
      const spot = nextEmpty();
      if (!spot) return false;
      state.pieces.push({ id: `${owner}_${idx++}`, owner, type, x: spot.x, y: spot.y });
    }
  }
  return true;
}
function generateStrictFairStart(maxTries){
  for (let i=0;i<maxTries;i++){
    state.pieces = [];
    if (!placePiecesNoClaim()) continue;
    if (!anyImmediateCaptureExists()) return true;
  }
  return false;
}

/* respawn fairness */
function canRespawnedPieceCaptureImmediately(type, owner, x, y){
  const temp = {id:"tmp", owner, type, x, y};
  return legalMovesFor(temp).some(m => m.capture);
}
function pickRandomRespawnSquareFair(type, owner){
  const opp = (owner===BLUE) ? RED : BLUE;

  const empties = [];
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      if (!isOccupied(x,y)) empties.push({x,y});
    }
  }
  if (!empties.length) return null;

  shuffleInPlace(empties);

  const tierA = [];
  const tierB = [];

  for (const s of empties){
    const noImmediateCapture = !canRespawnedPieceCaptureImmediately(type, owner, s.x, s.y);
    const notAttackedByOpp   = !squareAttackedByOwner(opp, s.x, s.y);
    if (noImmediateCapture) tierB.push(s);
    if (noImmediateCapture && notAttackedByOpp) tierA.push(s);
  }

  function pickFrom(list){
    if (!list.length) return null;
    shuffleInPlace(list);
    const k = Math.min(24, list.length);
    return list[Math.floor(rand01() * k)];
  }

  return pickFrom(tierA) || pickFrom(tierB) || pickFrom(empties);
}
function respawnSameType(capturedPiece){
  const spot = pickRandomRespawnSquareFair(capturedPiece.type, capturedPiece.owner);
  if (!spot) return false;
  capturedPiece.x = spot.x;
  capturedPiece.y = spot.y;
  return true;
}

/* end / overlay */
function showGameOverOverlay(a,b,verdict){
  finalBlueEl.textContent = a;
  finalRedEl.textContent = b;
  finalWinModeEl.textContent =
    (state.winMode==="line") ? "Complete a row or column" : "Most territory after turns";

  const set = currentPieceSet();
  finalSetEl.textContent = set.name;
  finalModeEl.textContent = (state.mode==="bot") ? "Vs Bot" : "2 Players";

  winnerBannerEl.className = "";
  winnerBannerEl.id = "winnerBanner";
  if (verdict==="Blue wins"){
    winnerBannerEl.classList.add("blue");
    winnerBannerEl.textContent = "BLUE WINS";
  } else if (verdict==="Red wins"){
    winnerBannerEl.classList.add("red");
    winnerBannerEl.textContent = "RED WINS";
  } else {
    winnerBannerEl.classList.add("draw");
    winnerBannerEl.textContent = "DRAW";
  }
  overlayEl.classList.add("show");
  document.body.classList.add("gameOver");
}
function finalizeGameByTerritory(){
  state.gameOver=true;
  state.busy=false;
  boardEl.classList.remove("disabled");
  clearMarks();
  renderPieces();
  const {a,b}=countTerritory();

  let verdict="Draw";
  if (a>b) verdict="Blue wins";
  if (b>a) verdict="Red wins";

  msgEl.textContent=`Game over. Blue: ${a} • Red: ${b}. ${verdict}.`;
  showGameOverOverlay(a,b,verdict);
}
function finalizeGameImmediate(winnerOwner){
  state.gameOver=true;
  state.busy=false;
  boardEl.classList.remove("disabled");
  clearMarks();
  renderPieces();
  const {a,b}=countTerritory();

  const verdict = (winnerOwner===BLUE) ? "Blue wins" : "Red wins";
  msgEl.textContent = `Game over. ${verdict} (row/column completed).`;
  showGameOverOverlay(a,b,verdict);
}

/* turn / bot */
function switchTurn(){
  if (state.winMode === "turns"){
    state.turnsLeft[state.current]-=1;
    if (state.turnsLeft[BLUE]<=0 && state.turnsLeft[RED]<=0){
      finalizeGameByTerritory();
      return;
    }
  }

  state.current = (state.current===BLUE) ? RED : BLUE;
  state.selectedId=null;
  clearMarks();
  setTurnUI();
  renderPieces();
  countTerritory();

  if (!state.gameOver && state.mode==="bot" && state.current===state.botColor){
    state.busy=true;
    boardEl.classList.add("disabled");
    setTimeout(botMove, BOT_THINK_MS);
  } else {
    state.busy=false;
    boardEl.classList.remove("disabled");
  }
}

/* move hints */
function highlightMoves(piece){
  for (const m of legalMovesFor(piece)){
    const el = document.getElementById(cellId(m.x,m.y));
    if (!el) continue;
    el.classList.add(m.capture ? "hintCapture" : "hint");
  }
}

/* interaction */
function canSelectPiece(p){
  if (state.mode==="bot") return p.owner===state.userColor;
  return p.owner===state.current;
}
function onCellClick(x,y){
  if (state.gameOver || state.busy) return;
  if (state.mode==="bot" && state.current===state.botColor) return;

  const clickedPiece = getPieceAt(x,y);

  if (!state.selectedId){
    if (!clickedPiece || !canSelectPiece(clickedPiece)) return;
    state.selectedId = clickedPiece.id;
    clearMarks();
    document.getElementById(cellId(clickedPiece.x, clickedPiece.y)).classList.add("sel");
    highlightMoves(clickedPiece);
    return;
  }

  const piece = state.pieces.find(p => p.id===state.selectedId);
  if (!piece){ state.selectedId=null; clearMarks(); return; }

  if (clickedPiece && canSelectPiece(clickedPiece) && clickedPiece.id !== piece.id){
    state.selectedId = clickedPiece.id;
    clearMarks();
    document.getElementById(cellId(clickedPiece.x, clickedPiece.y)).classList.add("sel");
    highlightMoves(clickedPiece);
    return;
  }

  const legal = legalMovesFor(piece).find(m => m.x===x && m.y===y);
  if (!legal) return;

  clearMarks();
  const captured = legal.capture ? getPieceAt(x,y) : null;

  /* execute move */
  piece.x = x; piece.y = y;
  claimCell(x,y, piece.owner);

  if (captured){
    const ok = respawnSameType(captured);
    if (!ok){ finalizeGameByTerritory(); return; }
  }

  renderPieces();
  countTerritory();

  if (maybeEndByLineWin(piece.owner)) return;

  switchTurn();
}

/* bot */
function evalMove(owner, move){
  const opp = (owner===BLUE) ? RED : BLUE;
  let s=0;

  const cellColor = state.territory[move.y][move.x];
  if (cellColor===0) s += 1.0;
  else if (cellColor===opp) s += 2.0;
  if (move.capture) s += 0.7;

  if (state.winMode === "line"){
    const prev = state.territory[move.y][move.x];
    state.territory[move.y][move.x] = owner;
    if (hasFullRowOrCol(owner)) s += 120;
    if (hasFullRowOrCol(opp)) s -= 40;
    state.territory[move.y][move.x] = prev;
  }

  const cx=(state.n-1)/2, cy=(state.n-1)/2;
  const dist=Math.abs(move.x-cx)+Math.abs(move.y-cy);
  s += Math.max(0, 0.25 - dist*0.04);
  return s;
}
function estimateBestAfter(ownerToMove){
  let best=-Infinity;
  for (const p of state.pieces.filter(pp=>pp.owner===ownerToMove)){
    for (const m of legalMovesFor(p)) best=Math.max(best, evalMove(ownerToMove,m));
  }
  return best===-Infinity?0:best;
}
function botMove(){
  if (state.gameOver || state.mode!=="bot" || state.current!==state.botColor) return;

  const botPieces = state.pieces.filter(p => p.owner===state.botColor);
  const opp = state.userColor;

  let bestPlan=null;

  for (const p of botPieces){
    for (const m of legalMovesFor(p)){
      const captured = m.capture ? getPieceAt(m.x, m.y) : null;

      const saved = {px:p.x, py:p.y, cap: captured ? {x:captured.x,y:captured.y} : null};
      p.x=m.x; p.y=m.y;
      if (captured){ captured.x=-99; captured.y=-99; }

      let s = evalMove(state.botColor, m);
      s -= 0.25 * estimateBestAfter(opp);

      p.x=saved.px; p.y=saved.py;
      if (captured){ captured.x=saved.cap.x; captured.y=saved.cap.y; }

      if (!bestPlan || s>bestPlan.score) bestPlan={piece:p, move:m, captured, score:s};
    }
  }

  if (!bestPlan){ finalizeGameByTerritory(); return; }

  clearMarks();
  const fromEl = document.getElementById(cellId(bestPlan.piece.x, bestPlan.piece.y));
  const toEl   = document.getElementById(cellId(bestPlan.move.x, bestPlan.move.y));
  if (fromEl) fromEl.classList.add("botFrom");
  if (toEl)   toEl.classList.add("botTo");

  setTimeout(()=>{
    if (state.gameOver) return;

    const {piece, move, captured} = bestPlan;

    piece.x = move.x; piece.y = move.y;
    claimCell(move.x, move.y, piece.owner);

    if (captured){
      const ok = respawnSameType(captured);
      if (!ok){ finalizeGameByTerritory(); return; }
    }

    renderPieces();
    countTerritory();

    if (maybeEndByLineWin(piece.owner)) return;

    state.busy=false;
    boardEl.classList.remove("disabled");
    switchTurn();
  }, BOT_SHOW_MS);
}

/* dropdown */
function fillPieceSetDropdown(){
  pieceSetSel.innerHTML = "";
  for (const s of PIECE_SETS){
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = s.name;
    pieceSetSel.appendChild(opt);
  }
  pieceSetSel.value = state.pieceSetId;
}
function updateSetNote(extra=""){
  const set = currentPieceSet();
  const counts = {};
  for (const t of set.perSide) counts[t] = (counts[t]||0) + 1;
  const parts = Object.keys(counts).map(k => `${counts[k]}×${k}`);
  setNote.textContent = `Per side: ${parts.join(", ")}. ${extra}`.trim();
}

/* new game */
function newGame(){
  overlayEl.classList.remove("show");
  document.body.classList.remove("gameOver");
  reseedRng();

  state.n = Number(boardSizeSel.value);
  state.mode = modeSel.value;
  state.winMode = winModeSel.value;
  state.pieceSetId = pieceSetSel.value || state.pieceSetId;

  state.turnLimit = Number(turnLimitSel.value);
  state.turnsLeft = { [BLUE]: state.turnLimit, [RED]: state.turnLimit };

  if (state.mode==="bot"){
    state.userColor = (rand01() < 0.5) ? BLUE : RED;
    state.botColor  = (state.userColor===BLUE) ? RED : BLUE;
    state.current   = (rand01() < 0.5) ? BLUE : RED;
  } else {
    state.userColor = BLUE;
    state.botColor  = RED;
    state.current   = BLUE;
  }

  state.selectedId = null;
  state.gameOver = false;
  state.busy = false;
  boardEl.classList.remove("disabled");

  buildBoard();

  const setSize = currentPieceSet().perSide.length;
  const tries = 2000 + setSize * 850;

  let ok = false;
  for (let attempt=0; attempt<tries; attempt++){
    ok = generateStrictFairStart(1);
    if (!ok) continue;

    initTerritory();
    for (const p of state.pieces) claimCell(p.x, p.y, p.owner);

    if (state.winMode === "line"){
      if (hasFullRowOrCol(BLUE) || hasFullRowOrCol(RED)) continue;
    }
    break;
  }

  if (!ok){
    initTerritory();
    generateStrictFairStart(tries);
    for (const p of state.pieces) claimCell(p.x, p.y, p.owner);
    updateSetNote("⚠️ Could not guarantee a fully fair start for this board/piece count.");
  } else {
    updateSetNote("Fair start: no immediate captures. Territory is shown by subtle tint.");
  }

  refreshAllTerritory();
  renderPieces();
  countTerritory();
  clearMarks();
  roleLabels();
  setTurnUI();

  if (state.mode==="bot" && state.current===state.botColor){
    state.busy=true;
    boardEl.classList.add("disabled");
    setTimeout(botMove, BOT_THINK_MS);
  }
}

/* wiring */
newGameBtn.addEventListener("click", newGame);
boardSizeSel.addEventListener("change", newGame);
turnLimitSel.addEventListener("change", newGame);
modeSel.addEventListener("change", newGame);
pieceSetSel.addEventListener("change", newGame);
winModeSel.addEventListener("change", newGame);

fillPieceSetDropdown();
newGame();
</script>
</body>
</html>