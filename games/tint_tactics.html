<!DOCTYPE html>
<html lang="en">
<head>
<meta charset="UTF-8" />
<meta name="viewport" content="width=device-width, initial-scale=1.0"/>
<title>Tint Tactics</title>

<style>
  :root{
    --cell: 54px;
    --gap: 2px;
    --n: 8;

    /* checked board */
    --sq-light: #f7f7f7;
    --sq-dark:  #e4e4e4;

    /* pale territory tints */
    --tint-blue: rgba(11, 87, 208, 0.16);
    --tint-red:  rgba(176, 0, 32, 0.16);

    /* piece colors */
    --blue: #0b57d0;
    --red:  #b00020;

    --grid-bg: #333;
    --frame: #222;
  }

  body{
    margin:0;
    padding:14px 10px 28px;
    font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif;
    background:#fafafa;
    color:#111;
    text-align:center;
  }
  h2{ margin:6px 0 8px; }

  #rules{
    width:min(100vw - 20px, 980px);
    margin:0 auto 10px;
    text-align:left;
    background:#fff;
    border:1px solid #e6e6e6;
    border-radius:12px;
    padding:10px 12px;
    line-height:1.35;
    font-size:13px;
    color:#222;
  }
  #rules b{ font-weight:800; }
  #rules ul{ margin:6px 0 0 18px; padding:0; }
  #rules li{ margin:3px 0; }

  #hud{
    display:flex;
    flex-wrap:wrap;
    justify-content:center;
    gap:10px 14px;
    align-items:center;
    margin-bottom:10px;
  }
  .pill{
    display:flex;
    gap:8px;
    align-items:center;
    padding:8px 10px;
    border:1px solid #ddd;
    border-radius:999px;
    background:#fff;
    white-space:nowrap;
  }
  .label{ color:#444; font-size:13px; }
  .value{ font-weight:800; font-size:16px; }
  .p1{ color:var(--blue); }
  .p2{ color:var(--red); }

  button, select{
    font-size:14px;
    padding:7px 10px;
  }

  #wrap{ width:min(100vw - 20px, 560px); margin:0 auto; }

  /* frame */
  #board{
    display:inline-block;
    border:2px solid var(--frame);
    background:var(--grid-bg);
    padding:2px;
    box-sizing:content-box;
  }

  #grid{
    display:grid;
    grid-template-columns: repeat(var(--n), var(--cell));
    grid-template-rows: repeat(var(--n), var(--cell));
    gap: var(--gap);
    background:var(--grid-bg);
  }

  .cell{
    position:relative;
    width:var(--cell);
    height:var(--cell);
    display:flex;
    align-items:center;
    justify-content:center;
    user-select:none;
    -webkit-tap-highlight-color: transparent;
    cursor:pointer;
    font-size: calc(var(--cell) * 0.56);
    line-height:1;
    background: var(--sq-light);
    font-family: "Apple Color Emoji","Segoe UI Symbol", system-ui, sans-serif;
  }
  .cell.parity1{ background: var(--sq-dark); }

  /* territory overlay keeps check pattern visible */
  .cell.c1{
    background-image: linear-gradient(var(--tint-blue), var(--tint-blue));
    background-blend-mode: multiply;
  }
  .cell.c2{
    background-image: linear-gradient(var(--tint-red), var(--tint-red));
    background-blend-mode: multiply;
  }

  /* selection + hints */
  .sel{
    outline: 3px solid rgba(0,0,0,0.45);
    outline-offset: -3px;
  }
  .hint{
    outline: 3px solid rgba(0,0,0,0.18);
    outline-offset: -3px;
  }
  .hintCapture{
    outline: 3px solid rgba(0,0,0,0.18);
    outline-offset: -3px;
    box-shadow: inset 0 0 0 999px rgba(0,0,0,0.05);
  }

  /* bot animation */
  .botFrom{
    outline: 3px solid rgba(176,0,32,0.45);
    outline-offset:-3px;
  }
  .botTo{
    outline: 3px solid rgba(176,0,32,0.25);
    outline-offset:-3px;
    box-shadow: inset 0 0 0 999px rgba(176,0,32,0.07);
  }

  /* Pieces: filled glyphs (black-piece Unicode) colored via CSS */
  .piece{
    font-weight:800;
    text-shadow: 0 1px 0 rgba(0,0,0,0.10);
  }
  .pieceBlue{ color: var(--blue); }
  .pieceRed { color: var(--red); }

  .disabled{
    opacity:0.72;
    pointer-events:none;
    filter: grayscale(0.10);
  }

  .msg{ margin-top:10px; font-size:13px; color:#444; }
  .legend{
    margin-top:8px;
    display:flex;
    justify-content:center;
    flex-wrap:wrap;
    gap:10px 14px;
    font-size:13px;
    color:#333;
  }
  .dot{
    display:inline-block;
    width:12px; height:12px;
    border-radius:999px;
    vertical-align:middle;
    margin-right:6px;
    border:1px solid rgba(0,0,0,0.18);
  }
  .dot1{ background: var(--tint-blue); }
  .dot2{ background: var(--tint-red); }

  .smallNote{ font-size:12px; color:#555; margin-top:6px; }

  option{ font-family: "Apple Color Emoji", "Segoe UI Symbol", system-ui, sans-serif; }

  /* ===== Game Over modal ===== */
  #overlay{
    position:fixed;
    inset:0;
    display:none;
    align-items:center;
    justify-content:center;
    background: rgba(0,0,0,0.45);
    z-index: 9999;
    padding: 18px;
  }
  #overlay.show{ display:flex; }
  #modal{
    width:min(92vw, 520px);
    border-radius:16px;
    background:#fff;
    border:2px solid rgba(0,0,0,0.15);
    box-shadow: 0 14px 50px rgba(0,0,0,0.25);
    padding: 16px 16px 14px;
    text-align:left;
  }
  #modal h3{
    margin:0 0 8px;
    font-size: 18px;
  }
  #winnerBanner{
    margin: 8px 0 12px;
    padding: 10px 12px;
    border-radius: 12px;
    font-weight: 850;
    font-size: 18px;
    letter-spacing: 0.2px;
    border: 1px solid rgba(0,0,0,0.12);
  }
  #winnerBanner.blue{
    color: var(--blue);
    background: rgba(11,87,208,0.10);
  }
  #winnerBanner.red{
    color: var(--red);
    background: rgba(176,0,32,0.10);
  }
  #winnerBanner.draw{
    color: #222;
    background: rgba(0,0,0,0.06);
  }
  #modal .row{
    display:flex;
    justify-content:space-between;
    margin: 6px 0;
    font-size:14px;
  }
  #modal .row b{ font-weight:800; }
  #modal .actions{
    margin-top: 12px;
    display:flex;
    gap: 10px;
    justify-content:flex-end;
  }
</style>
</head>

<body>
<h2>Tint Tactics</h2>

<div id="rules">
  <b>Goal:</b> After a fixed number of turns, control more territory.
  <ul>
    <li>Move like chess. No check rules.</li>
    <li>Your <b>destination square</b> becomes your color (overwrites the opponent’s color).</li>
    <li>If you capture an enemy piece, it <b>respawns as the same type</b> on a random empty square. Respawning does <b>not</b> color the square.</li>
    <li><b>Fair respawn:</b> respawn squares are chosen so the respawned piece has <b>no immediate captures</b> if possible.</li>
    <li><b>Fair start:</b> initial positions are generated so <b>no immediate captures</b> are possible for either side.</li>
    <li><b>Vs Bot:</b> your color and the starting side are randomized (shown in the HUD).</li>
  </ul>
</div>

<div id="hud">
  <div class="pill">
    <span class="label">Mode:</span>
    <select id="modeSel">
      <option value="bot" selected>Vs Bot</option>
      <option value="2p">2 Players</option>
    </select>
  </div>

  <div class="pill" id="whoPill">
    <span class="label">You:</span>
    <span class="value" id="youColorText"></span>
    <span class="label" style="margin-left:8px;">Bot:</span>
    <span class="value" id="botColorText"></span>
  </div>

  <div class="pill">
    <span class="label">Piece set:</span>
    <select id="pieceSetSel"></select>
  </div>

  <div class="pill">
    <span class="label">Turn:</span>
    <span class="value" id="turnText"></span>
  </div>

  <div class="pill">
    <span class="label">Turns left:</span>
    <span class="value" id="turnsLeft">20</span>
  </div>

  <div class="pill">
    <span class="label"><span class="p1">Blue</span> territory:</span>
    <span class="value p1" id="score1">0</span>
  </div>

  <div class="pill">
    <span class="label"><span class="p2">Red</span> territory:</span>
    <span class="value p2" id="score2">0</span>
  </div>

  <div class="pill">
    <span class="label">Board:</span>
    <select id="boardSize">
      <option value="6">6×6</option>
      <option value="7">7×7</option>
      <option value="8" selected>8×8</option>
      <option value="9">9×9</option>
    </select>
  </div>

  <div class="pill">
    <span class="label">Turns/side:</span>
    <select id="turnLimit">
      <option value="10">10</option>
      <option value="15">15</option>
      <option value="20" selected>20</option>
      <option value="25">25</option>
      <option value="30">30</option>
    </select>
  </div>

  <button id="newGameBtn">New Game</button>
</div>

<div id="wrap">
  <div id="board"><div id="grid"></div></div>
  <div class="smallNote" id="setNote"></div>
</div>

<div class="legend">
  <span><span class="dot dot1"></span>Blue territory</span>
  <span><span class="dot dot2"></span>Red territory</span>
</div>

<div class="msg" id="msg">Click a piece, then a highlighted destination.</div>

<!-- Game Over Overlay -->
<div id="overlay" role="dialog" aria-modal="true" aria-label="Game Over">
  <div id="modal">
    <h3>Game Over</h3>
    <div id="winnerBanner" class="draw">DRAW</div>
    <div class="row"><span>Blue territory</span> <b id="finalBlue">0</b></div>
    <div class="row"><span>Red territory</span> <b id="finalRed">0</b></div>
    <div class="row"><span>Piece set</span> <b id="finalSet">—</b></div>
    <div class="row"><span>Mode</span> <b id="finalMode">—</b></div>
    <div class="actions">
      <button id="closeOverlayBtn">Close</button>
      <button id="playAgainBtn">Play again</button>
    </div>
  </div>
</div>

<script>
const BLUE = 1;
const RED  = 2;

/* FILLED glyphs (black-piece Unicode), colored via CSS */
const GLYPH = {
  rook:   "♜",
  bishop: "♝",
  knight: "♞",
  queen:  "♛",
  king:   "♚",
  pawn:   "♟"
};

const PIECE_SETS = [
  { id:"mini3",    name:"♜ ♝ ♞",              perSide:["rook","bishop","knight"] },
  { id:"classic6", name:"♜ ♞ ♞ ♝ ♝ ♚",        perSide:["rook","knight","knight","bishop","bishop","king"] },
  { id:"queen4",   name:"♛ ♜ ♝ ♞",            perSide:["queen","rook","bishop","knight"] },
  { id:"queen5k",  name:"♛ ♜ ♝ ♞ ♚",          perSide:["queen","rook","bishop","knight","king"] },
  { id:"queen6",   name:"♛ ♜ ♞ ♞ ♝ ♚",        perSide:["queen","rook","knight","knight","bishop","king"] },
  { id:"pawnsLite6", name:"♜ ♝ ♞ ♚ ♟ ♟",      perSide:["rook","bishop","knight","king","pawn","pawn"] },
  { id:"pawnsPlus8", name:"♛ ♜ ♝ ♞ ♚ ♟ ♟ ♟",  perSide:["queen","rook","bishop","knight","king","pawn","pawn","pawn"] }
];

const BOT_THINK_MS = 450;
const BOT_SHOW_MS  = 420;

/* === RNG (per game) to avoid positional loops and allow randomized starts/colors === */
let RNG_SEED = 0;
function reseedRng(){
  RNG_SEED = (Date.now() ^ ((Math.random()*1e9)|0)) >>> 0;
}
function rand01(){
  // xorshift32
  RNG_SEED ^= (RNG_SEED << 13); RNG_SEED >>>= 0;
  RNG_SEED ^= (RNG_SEED >>> 17); RNG_SEED >>>= 0;
  RNG_SEED ^= (RNG_SEED << 5);  RNG_SEED >>>= 0;
  return (RNG_SEED >>> 0) / 4294967296;
}
function shuffleInPlace(arr){
  for (let i=arr.length-1; i>0; i--){
    const j = Math.floor(rand01() * (i+1));
    [arr[i], arr[j]] = [arr[j], arr[i]];
  }
}
function pickRandom(arr){
  return arr[Math.floor(rand01() * arr.length)];
}

const state = {
  n: 8,
  turnLimit: 20,
  turnsLeft: { [BLUE]: 20, [RED]: 20 },
  current: BLUE,
  selectedId: null,
  gameOver: false,
  busy: false,
  mode: "bot",
  territory: [],
  pieces: [],
  pieceSetId: "queen5k",

  /* NEW: explicit roles in bot mode */
  userColor: BLUE,
  botColor: RED
};

const gridEl = document.getElementById("grid");
const msgEl = document.getElementById("msg");
const turnTextEl = document.getElementById("turnText");
const turnsLeftEl = document.getElementById("turnsLeft");
const score1El = document.getElementById("score1");
const score2El = document.getElementById("score2");
const boardSizeSel = document.getElementById("boardSize");
const turnLimitSel = document.getElementById("turnLimit");
const newGameBtn = document.getElementById("newGameBtn");
const modeSel = document.getElementById("modeSel");
const boardEl = document.getElementById("board");
const pieceSetSel = document.getElementById("pieceSetSel");
const setNote = document.getElementById("setNote");

const whoPill = document.getElementById("whoPill");
const youColorText = document.getElementById("youColorText");
const botColorText = document.getElementById("botColorText");

/* overlay */
const overlayEl = document.getElementById("overlay");
const winnerBannerEl = document.getElementById("winnerBanner");
const finalBlueEl = document.getElementById("finalBlue");
const finalRedEl = document.getElementById("finalRed");
const finalSetEl = document.getElementById("finalSet");
const finalModeEl = document.getElementById("finalMode");
const closeOverlayBtn = document.getElementById("closeOverlayBtn");
const playAgainBtn = document.getElementById("playAgainBtn");

closeOverlayBtn.addEventListener("click", () => overlayEl.classList.remove("show"));
playAgainBtn.addEventListener("click", () => { overlayEl.classList.remove("show"); newGame(); });

function setCellSize(){
  const wrap = document.getElementById("wrap");
  const w = wrap.getBoundingClientRect().width;
  const n = state.n;
  const usable = Math.floor(w - 14);
  const cell = Math.max(34, Math.min(72, Math.floor((usable - (n-1)*2 - 4) / n)));
  document.documentElement.style.setProperty("--cell", cell + "px");
}
window.addEventListener("resize", setCellSize);

function inBounds(x,y){ return x>=0 && x<state.n && y>=0 && y<state.n; }
function cellId(x,y){ return `c_${x}_${y}`; }
function getPieceAt(x,y){ return state.pieces.find(p => p.x===x && p.y===y) || null; }
function isOccupied(x,y){ return !!getPieceAt(x,y); }

function clearMarks(){
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.getElementById(cellId(x,y));
      el.classList.remove("sel","hint","hintCapture","botFrom","botTo");
    }
  }
}

function cssColorName(owner){
  return owner===BLUE ? `<span class="p1">Blue</span>` : `<span class="p2">Red</span>`;
}
function roleLabels(){
  if (state.mode !== "bot"){
    whoPill.style.display = "none";
    return;
  }
  whoPill.style.display = "flex";
  youColorText.innerHTML = cssColorName(state.userColor);
  botColorText.innerHTML = cssColorName(state.botColor);
}

function setTurnUI(){
  turnTextEl.innerHTML = cssColorName(state.current);
  turnsLeftEl.textContent = state.turnsLeft[state.current];

  if (state.gameOver) return;

  if (state.mode==="bot"){
    const isBotTurn = (state.current === state.botColor);
    msgEl.textContent = isBotTurn ? "Bot is thinking…" : "Your turn: click a piece, then a highlighted destination.";
  }else{
    msgEl.textContent = "Click a piece, then a highlighted destination.";
  }
}

/* territory */
function initTerritory(){
  state.territory = Array.from({length: state.n}, () => Array(state.n).fill(0));
}
function applyTerritoryClass(el, owner){
  el.classList.remove("c1","c2");
  if (owner===BLUE) el.classList.add("c1");
  else if (owner===RED) el.classList.add("c2");
}
function colorCell(x,y, owner){
  state.territory[y][x] = owner;
  const el = document.getElementById(cellId(x,y));
  if (el) applyTerritoryClass(el, owner);
}
function refreshAllTerritory(){
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.getElementById(cellId(x,y));
      if (!el) continue;
      applyTerritoryClass(el, state.territory[y][x]);
    }
  }
}
function countTerritory(){
  let a=0,b=0;
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      if (state.territory[y][x]===BLUE) a++;
      else if (state.territory[y][x]===RED) b++;
    }
  }
  score1El.textContent = a;
  score2El.textContent = b;
  return {a,b};
}

/* board */
function buildBoard(){
  document.documentElement.style.setProperty("--n", state.n);
  gridEl.innerHTML = "";
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.createElement("div");
      el.id = cellId(x,y);
      el.className = "cell" + (((x+y)%2) ? " parity1" : "");
      el.addEventListener("click", () => onCellClick(x,y), {passive:true});
      gridEl.appendChild(el);
    }
  }
  setCellSize();
}

function renderPieces(){
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      const el = document.getElementById(cellId(x,y));
      el.textContent = "";
      el.classList.remove("piece","pieceBlue","pieceRed");
    }
  }
  for (const p of state.pieces){
    const el = document.getElementById(cellId(p.x,p.y));
    if (!el) continue;
    el.textContent = GLYPH[p.type] || "?";
    el.classList.add("piece", p.owner===BLUE ? "pieceBlue" : "pieceRed");
  }
}

/* moves */
function rayMoves(p, dirs){
  const moves = [];
  for (const [dx,dy] of dirs){
    let x=p.x+dx, y=p.y+dy;
    while (inBounds(x,y)){
      const occ=getPieceAt(x,y);
      if (!occ) moves.push({x,y,capture:false});
      else { if (occ.owner!==p.owner) moves.push({x,y,capture:true}); break; }
      x+=dx; y+=dy;
    }
  }
  return moves;
}
function knightMoves(p){
  const deltas=[[2,1],[2,-1],[-2,1],[-2,-1],[1,2],[1,-2],[-1,2],[-1,-2]];
  const moves=[];
  for (const [dx,dy] of deltas){
    const x=p.x+dx, y=p.y+dy;
    if (!inBounds(x,y)) continue;
    const occ=getPieceAt(x,y);
    if (!occ) moves.push({x,y,capture:false});
    else if (occ.owner!==p.owner) moves.push({x,y,capture:true});
  }
  return moves;
}
function kingMoves(p){
  const moves=[];
  for (let dy=-1; dy<=1; dy++){
    for (let dx=-1; dx<=1; dx++){
      if (dx===0 && dy===0) continue;
      const x=p.x+dx, y=p.y+dy;
      if (!inBounds(x,y)) continue;
      const occ=getPieceAt(x,y);
      if (!occ) moves.push({x,y,capture:false});
      else if (occ.owner!==p.owner) moves.push({x,y,capture:true});
    }
  }
  return moves;
}
function pawnMoves(p){
  const dir = (p.owner===BLUE) ? -1 : 1;
  const moves=[];
  const fwdY = p.y + dir;

  if (inBounds(p.x, fwdY) && !isOccupied(p.x, fwdY)){
    moves.push({x:p.x, y:fwdY, capture:false});
  }
  for (const dx of [-1, 1]){
    const cx = p.x + dx, cy = p.y + dir;
    if (!inBounds(cx,cy)) continue;
    const occ = getPieceAt(cx,cy);
    if (occ && occ.owner !== p.owner){
      moves.push({x:cx, y:cy, capture:true});
    }
  }
  return moves;
}

function legalMovesFor(p){
  if (p.type==="rook")   return rayMoves(p, [[1,0],[-1,0],[0,1],[0,-1]]);
  if (p.type==="bishop") return rayMoves(p, [[1,1],[1,-1],[-1,1],[-1,-1]]);
  if (p.type==="queen")  return rayMoves(p, [[1,0],[-1,0],[0,1],[0,-1],[1,1],[1,-1],[-1,1],[-1,-1]]);
  if (p.type==="knight") return knightMoves(p);
  if (p.type==="king")   return kingMoves(p);
  if (p.type==="pawn")   return pawnMoves(p);
  return [];
}

/* ==========================
   STRICT FAIR START (FIXED)
   ==========================

   Key fix: while searching for a start, we DO NOT color and we DO NOT accept
   any arrangement that yields ANY immediate capture for EITHER side.

   After we find a valid arrangement, then we initialize territory and color the
   starting squares (as before).
*/
function anyImmediateCaptureExists(){
  for (const p of state.pieces){
    const moves = legalMovesFor(p);
    for (const m of moves){
      if (m.capture) return true;
    }
  }
  return false;
}

function currentPieceSet(){
  return PIECE_SETS.find(s => s.id===state.pieceSetId) || PIECE_SETS[0];
}

function placePiecesNoColor(){
  state.pieces = [];
  const set = currentPieceSet();
  let idx = 0;

  // Build list of all squares and shuffle so placement is unbiased.
  const squares = [];
  for (let y=0;y<state.n;y++) for (let x=0;x<state.n;x++) squares.push({x,y});
  shuffleInPlace(squares);

  let ptr = 0;
  function nextEmpty(){
    while (ptr < squares.length){
      const s = squares[ptr++];
      if (!isOccupied(s.x,s.y)) return s;
    }
    return null;
  }

  for (const owner of [BLUE, RED]){
    for (const type of set.perSide){
      const spot = nextEmpty();
      if (!spot) return false;
      state.pieces.push({ id: `${owner}_${idx++}`, owner, type, x: spot.x, y: spot.y });
    }
  }
  return true;
}

function generateStrictFairStart(maxTries){
  for (let i=0;i<maxTries;i++){
    state.pieces = [];
    if (!placePiecesNoColor()) continue;
    if (!anyImmediateCaptureExists()) return true;
  }
  return false;
}

/* respawn fairness + randomness */
function canPieceCaptureAnyFrom(type, owner, x, y){
  const temp = {id:"tmp", owner, type, x, y};
  return legalMovesFor(temp).some(m => m.capture);
}

function pickRandomRespawnSquareFair(type, owner){
  const empties = [];
  for (let y=0;y<state.n;y++){
    for (let x=0;x<state.n;x++){
      if (!isOccupied(x,y)) empties.push({x,y});
    }
  }
  if (!empties.length) return null;

  shuffleInPlace(empties);

  const safe = [];
  for (const s of empties){
    if (!canPieceCaptureAnyFrom(type, owner, s.x, s.y)) safe.push(s);
  }

  if (safe.length){
    // pick randomly among a shuffled top subset to avoid loops
    shuffleInPlace(safe);
    const k = Math.min(14, safe.length);
    return safe[Math.floor(rand01()*k)];
  }

  return pickRandom(empties);
}

function respawnSameType(capturedPiece){
  const spot = pickRandomRespawnSquareFair(capturedPiece.type, capturedPiece.owner);
  if (!spot) return false;
  capturedPiece.x = spot.x;
  capturedPiece.y = spot.y;
  return true;
}

/* end/turn */
function showGameOverOverlay(a,b,verdict){
  finalBlueEl.textContent = a;
  finalRedEl.textContent = b;

  const set = currentPieceSet();
  finalSetEl.textContent = set.name;
  finalModeEl.textContent = (state.mode==="bot") ? "Vs Bot" : "2 Players";

  winnerBannerEl.className = "";
  winnerBannerEl.id = "winnerBanner";
  if (verdict==="Blue wins"){
    winnerBannerEl.classList.add("blue");
    winnerBannerEl.textContent = "BLUE WINS";
  } else if (verdict==="Red wins"){
    winnerBannerEl.classList.add("red");
    winnerBannerEl.textContent = "RED WINS";
  } else {
    winnerBannerEl.classList.add("draw");
    winnerBannerEl.textContent = "DRAW";
  }
  overlayEl.classList.add("show");
}

function finalizeGame(){
  state.gameOver=true;
  state.busy=false;
  boardEl.classList.remove("disabled");
  clearMarks();
  renderPieces();
  const {a,b}=countTerritory();

  let verdict="Draw";
  if (a>b) verdict="Blue wins";
  if (b>a) verdict="Red wins";

  msgEl.textContent=`Game over. Blue: ${a} • Red: ${b}. ${verdict}.`;
  showGameOverOverlay(a,b,verdict);
}

function switchTurn(){
  state.turnsLeft[state.current]-=1;
  if (state.turnsLeft[BLUE]<=0 && state.turnsLeft[RED]<=0){ finalizeGame(); return; }

  state.current = (state.current===BLUE) ? RED : BLUE;
  state.selectedId=null;
  clearMarks();
  setTurnUI();
  renderPieces();
  countTerritory();

  if (!state.gameOver && state.mode==="bot" && state.current===state.botColor){
    state.busy=true;
    boardEl.classList.add("disabled");
    setTimeout(botMove, BOT_THINK_MS);
  } else {
    state.busy=false;
    boardEl.classList.remove("disabled");
  }
}

/* hints */
function highlightMoves(piece){
  for (const m of legalMovesFor(piece)){
    const el = document.getElementById(cellId(m.x,m.y));
    if (!el) continue;
    el.classList.add(m.capture ? "hintCapture" : "hint");
  }
}

/* interaction */
function canSelectPiece(p){
  if (state.mode==="bot") return p.owner===state.userColor;
  return p.owner===state.current;
}

function onCellClick(x,y){
  if (state.gameOver || state.busy) return;

  // if bot mode and it's bot's turn, ignore clicks
  if (state.mode==="bot" && state.current===state.botColor) return;

  const clickedPiece = getPieceAt(x,y);

  if (!state.selectedId){
    if (!clickedPiece || !canSelectPiece(clickedPiece)) return;
    state.selectedId = clickedPiece.id;
    clearMarks();
    document.getElementById(cellId(clickedPiece.x, clickedPiece.y)).classList.add("sel");
    highlightMoves(clickedPiece);
    return;
  }

  const piece = state.pieces.find(p => p.id===state.selectedId);
  if (!piece){ state.selectedId=null; clearMarks(); return; }

  if (clickedPiece && canSelectPiece(clickedPiece) && clickedPiece.id !== piece.id){
    state.selectedId = clickedPiece.id;
    clearMarks();
    document.getElementById(cellId(clickedPiece.x, clickedPiece.y)).classList.add("sel");
    highlightMoves(clickedPiece);
    return;
  }

  const legal = legalMovesFor(piece).find(m => m.x===x && m.y===y);
  if (!legal) return;

  clearMarks();
  const captured = legal.capture ? getPieceAt(x,y) : null;

  piece.x = x; piece.y = y;
  colorCell(x,y, piece.owner);

  if (captured){
    const ok = respawnSameType(captured);
    if (!ok){ finalizeGame(); return; }
  }

  renderPieces();
  countTerritory();
  switchTurn();
}

/* bot */
function evalMove(owner, move){
  const opp = (owner===BLUE) ? RED : BLUE;
  let s=0;
  const cellColor = state.territory[move.y][move.x];
  if (cellColor===0) s += 1.0;
  else if (cellColor===opp) s += 2.0;
  if (move.capture) s += 0.7;

  const cx=(state.n-1)/2, cy=(state.n-1)/2;
  const dist=Math.abs(move.x-cx)+Math.abs(move.y-cy);
  s += Math.max(0, 0.25 - dist*0.04);
  return s;
}

function estimateBestAfter(ownerToMove){
  let best=-Infinity;
  for (const p of state.pieces.filter(pp=>pp.owner===ownerToMove)){
    for (const m of legalMovesFor(p)) best=Math.max(best, evalMove(ownerToMove,m));
  }
  return best===-Infinity?0:best;
}

function botMove(){
  if (state.gameOver || state.mode!=="bot" || state.current!==state.botColor) return;

  const botPieces = state.pieces.filter(p => p.owner===state.botColor);
  const opp = state.userColor;

  let bestPlan=null;

  for (const p of botPieces){
    for (const m of legalMovesFor(p)){
      const captured = m.capture ? getPieceAt(m.x, m.y) : null;

      // simulate quickly
      const saved = {px:p.x, py:p.y, cap: captured ? {x:captured.x,y:captured.y} : null};
      p.x=m.x; p.y=m.y;
      if (captured){ captured.x=-99; captured.y=-99; }

      let s = evalMove(state.botColor, m);
      // slight lookahead penalty: allow opponent's best response
      s -= 0.25 * estimateBestAfter(opp);

      // revert
      p.x=saved.px; p.y=saved.py;
      if (captured){ captured.x=saved.cap.x; captured.y=saved.cap.y; }

      if (!bestPlan || s>bestPlan.score) bestPlan={piece:p, move:m, captured, score:s};
    }
  }

  if (!bestPlan){ finalizeGame(); return; }

  clearMarks();
  const fromEl = document.getElementById(cellId(bestPlan.piece.x, bestPlan.piece.y));
  const toEl   = document.getElementById(cellId(bestPlan.move.x, bestPlan.move.y));
  if (fromEl) fromEl.classList.add("botFrom");
  if (toEl) toEl.classList.add("botTo");

  setTimeout(()=>{
    if (state.gameOver) return;

    const {piece, move, captured} = bestPlan;

    piece.x = move.x; piece.y = move.y;
    colorCell(move.x, move.y, piece.owner);

    if (captured){
      const ok = respawnSameType(captured);
      if (!ok){ finalizeGame(); return; }
    }

    renderPieces();
    countTerritory();

    state.busy=false;
    boardEl.classList.remove("disabled");
    switchTurn();
  }, BOT_SHOW_MS);
}

/* dropdown */
function fillPieceSetDropdown(){
  pieceSetSel.innerHTML = "";
  for (const s of PIECE_SETS){
    const opt = document.createElement("option");
    opt.value = s.id;
    opt.textContent = s.name;
    pieceSetSel.appendChild(opt);
  }
  pieceSetSel.value = state.pieceSetId;
}

function updateSetNote(extra=""){
  const set = currentPieceSet();
  const counts = {};
  for (const t of set.perSide) counts[t] = (counts[t]||0) + 1;
  const parts = Object.keys(counts).map(k => `${counts[k]}×${k}`);
  setNote.textContent = `Per side: ${parts.join(", ")}. ${extra}`.trim();
}

/* new game */
function newGame(){
  overlayEl.classList.remove("show");
  reseedRng();

  state.n = Number(boardSizeSel.value);
  state.turnLimit = Number(turnLimitSel.value);
  state.mode = modeSel.value;
  state.pieceSetId = pieceSetSel.value || state.pieceSetId;

  // Randomize roles + starting side in bot mode
  if (state.mode==="bot"){
    state.userColor = (rand01() < 0.5) ? BLUE : RED;
    state.botColor  = (state.userColor===BLUE) ? RED : BLUE;
    state.current   = (rand01() < 0.5) ? BLUE : RED; // random starter (independent)
  } else {
    state.userColor = BLUE;
    state.botColor  = RED;
    state.current   = BLUE;
  }

  state.turnsLeft = { [BLUE]: state.turnLimit, [RED]: state.turnLimit };
  state.selectedId = null;
  state.gameOver = false;
  state.busy = false;
  boardEl.classList.remove("disabled");

  buildBoard();

  // Strict fair start (try hard)
  const setSize = currentPieceSet().perSide.length;
  const tries = 1500 + setSize * 600;

  const ok = generateStrictFairStart(tries);

  initTerritory();
  if (ok){
    // color initial squares AFTER we know it is fair
    for (const p of state.pieces) colorCell(p.x, p.y, p.owner);
    updateSetNote("Fair start: no immediate captures.");
  } else {
    // This should be rare: too many pieces / too small board.
    // Still start, but loudly tell you it's not guaranteed.
    for (const p of state.pieces) colorCell(p.x, p.y, p.owner);
    updateSetNote("⚠️ Could not guarantee a fair start for this board/piece count.");
  }

  refreshAllTerritory();
  renderPieces();
  countTerritory();
  clearMarks();
  roleLabels();
  setTurnUI();

  // If bot starts, immediately play
  if (state.mode==="bot" && state.current===state.botColor){
    state.busy=true;
    boardEl.classList.add("disabled");
    setTimeout(botMove, BOT_THINK_MS);
  }
}

newGameBtn.addEventListener("click", newGame);
boardSizeSel.addEventListener("change", newGame);
turnLimitSel.addEventListener("change", newGame);
modeSel.addEventListener("change", newGame);
pieceSetSel.addEventListener("change", newGame);

/* init */
fillPieceSetDropdown();
newGame();
</script>
</body>
</html>